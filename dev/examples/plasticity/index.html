<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plasticity · FESolvers.jl</title><meta name="title" content="Plasticity · FESolvers.jl"/><meta property="og:title" content="Plasticity · FESolvers.jl"/><meta property="twitter:title" content="Plasticity · FESolvers.jl"/><meta name="description" content="Documentation for FESolvers.jl."/><meta property="og:description" content="Documentation for FESolvers.jl."/><meta property="twitter:description" content="Documentation for FESolvers.jl."/><meta property="og:url" content="https://KnutAM.github.io/FESolvers.jl/examples/plasticity/"/><meta property="twitter:url" content="https://KnutAM.github.io/FESolvers.jl/examples/plasticity/"/><link rel="canonical" href="https://KnutAM.github.io/FESolvers.jl/examples/plasticity/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FESolvers.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../userfunctions/">User problem</a></li><li><a class="tocitem" href="../../nlsolvers/">Nonlinear solvers</a></li><li><a class="tocitem" href="../../timesteppers/">Time steppers</a></li><li><a class="tocitem" href="../../linearsolvers/">Linear solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Plasticity</a><ul class="internal"><li><a class="tocitem" href="#Problem-definition"><span>Problem definition</span></a></li><li><a class="tocitem" href="#Neumann-boundary-conditions"><span>Neumann boundary conditions</span></a></li><li><a class="tocitem" href="#Specialized-functions-for-our-problem"><span>Specialized functions for our problem</span></a></li><li><a class="tocitem" href="#Solving-the-problem"><span>Solving the problem</span></a></li><li><a class="tocitem" href="#Plain-program"><span>Plain program</span></a></li></ul></li><li><a class="tocitem" href="../transient_heat/">Linear Time Dependent Problem</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Plasticity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plasticity</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/KnutAM/FESolvers.jl/blob/main/docs/src/literate/plasticity.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Plasticity"><a class="docs-heading-anchor" href="#Plasticity">Plasticity</a><a id="Plasticity-1"></a><a class="docs-heading-anchor-permalink" href="#Plasticity" title="Permalink"></a></h1><p>This example is based on <a href="https://ferrite-fem.github.io/Ferrite.jl/stable/examples/plasticity/">Ferrite.jl&#39;s plasticity example</a> and modified to show how <code>FESolvers</code> can be used to solve this nonlinear problem with time dependent loading.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This example is preliminary, and doesn&#39;t necessarily represent good coding practice. As an example of a more general implementation, please see <a href="https://github.com/KnutAM/FerriteProblems.jl"><code>FerriteProblems.jl</code></a> and its <a href="https://knutam.github.io/FerriteProblems.jl/dev/examples/plasticity/">example</a></p></div></div><p>First we need to load all required packages</p><pre><code class="language-julia hljs">using FESolvers, Ferrite, Tensors, SparseArrays, LinearAlgebra, Plots</code></pre><p>We first include some basic definitions taken and modified from the original <a href="https://ferrite-fem.github.io/Ferrite.jl/stable/examples/plasticity/">example</a>, specifically the material definitions: <code>J2Plasticity</code> and <code>J2PlasticityMaterialState</code>, as well as the <code>doassemble!</code> function. The exact definitions are available here: <a href="../plasticity_definitions.jl">plasticity_definitions.jl</a>,</p><pre><code class="language-julia hljs">include(&quot;plasticity_definitions.jl&quot;);</code></pre><h2 id="Problem-definition"><a class="docs-heading-anchor" href="#Problem-definition">Problem definition</a><a id="Problem-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-definition" title="Permalink"></a></h2><p>We divide the problem struct into three parts: definitions (<code>def</code>), a buffer (<code>buf</code>), and postprocessing (<code>post</code>) to structure the information and make it easier to save the simulation settings (enough to save <code>def</code> as the others will be created based on this one)</p><pre><code class="language-julia hljs">struct PlasticityProblem{PD,PB,PP}
    def::PD
    buf::PB
    post::PP
end</code></pre><p><code>PlasticityModel</code> is our <code>def</code> and contain all problem settings (mesh, material, loads, interpolations, etc.)</p><pre><code class="language-julia hljs">struct PlasticityModel{DH,CH,IP,M}
    dh::DH
    ch::CH
    interpolation::IP
    material::M
    traction_rate::Float64
end

function PlasticityModel()
    # Material
    E = 200.0e9; ν = 0.3    # Young&#39;s modulus and Poisson&#39;s ratio
    σ₀ = 200e6; H = E/20    # Yield limit and hardening modulus
    material = J2Plasticity(E, ν, σ₀, H)

    # Geometry (length, width, height)
    L = 10.0; w = 1.0; h = 1.0

    # Loading
    traction_rate = 1.e7    # N/s

    # Grid (beam)
    nels = (20, 2, 4)
    grid = generate_grid(Tetrahedron, nels, zero(Vec{3}), Vec((L, w, h)))

    # Interpolation and DofHandler
    ip = Lagrange{3, RefTetrahedron, 1}()
    dh = DofHandler(grid)
    add!(dh, :u, 3, ip)
    close!(dh)

    # ConstraintHandler
    ch = ConstraintHandler(dh)
    add!(ch, Dirichlet(:u, getfaceset(grid, &quot;left&quot;), Returns(zeros(3))))
    close!(ch)
    return PlasticityModel(dh, ch, ip, material, traction_rate)
end;</code></pre><p><code>PlasticityFEBuffer</code> is our <code>buf</code> and contains all problem arrays and other allocated values</p><pre><code class="language-julia hljs">struct PlasticityFEBuffer{CV,FV,KT,T,ST}
    cv::CV          # CellValues
    fv::FV          # FaceValues
    K::KT           # Stiffness matrix
    r::Vector{T}    # Residual vector
    u::Vector{T}    # Unknown vector
    states::Matrix{ST}
    states_old::Matrix{ST}
    time::Vector{T}     # Just a vector to allow mutating the time
    old_time::Vector{T} # Same as time (not needed, but shown for completeness)
end

function build_febuffer(model::PlasticityModel)
    dh = model.dh
    n_dofs = ndofs(dh)
    qr      = QuadratureRule{3,RefTetrahedron}(2)
    face_qr = QuadratureRule{2,RefTetrahedron}(3)
    ip_geo = Ferrite.default_interpolation(Ferrite.getcelltype(dh.grid))
    cv = CellVectorValues(qr, model.interpolation, ip_geo)
    fv = FaceVectorValues(face_qr, model.interpolation, ip_geo)
    u  = zeros(n_dofs)
    r = zeros(n_dofs)
    K = create_sparsity_pattern(dh)
    nqp = getnquadpoints(cv)
    states = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.dh.grid)]
    states_old = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.dh.grid)]
    return PlasticityFEBuffer(cv,fv,K,r,u,states,states_old,[0.0], [0.0])
end;</code></pre><p>Finally, we define our <code>post</code> that contains variables that we will save during the simulation</p><pre><code class="language-julia hljs">struct PlasticityPost{T}
    umax::Vector{T}
    tmag::Vector{T}
end
PlasticityPost() = PlasticityPost(Float64[],Float64[]);</code></pre><p>To facilitate reuse, we define a function that gives our full problem struct based on the problem definition</p><pre><code class="language-julia hljs">build_problem(def::PlasticityModel) = PlasticityProblem(def, build_febuffer(def), PlasticityPost());</code></pre><h2 id="Neumann-boundary-conditions"><a class="docs-heading-anchor" href="#Neumann-boundary-conditions">Neumann boundary conditions</a><a id="Neumann-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Neumann-boundary-conditions" title="Permalink"></a></h2><p>We then define a separate function for the Neumann boundary conditions (note that this difference to the original example is not required, but only to separate the element assembly and external boundary conditions) This could also be further simplified by using <a href="https://github.com/KnutAM/FerriteNeumann.jl">FerriteNeumann.jl</a></p><pre><code class="language-julia hljs">function apply_neumann!(model::PlasticityModel,buf::PlasticityFEBuffer)
    t = buf.time[1]
    nu = getnbasefunctions(buf.cv)
    re = zeros(nu)
    facevalues = buf.fv
    grid = model.dh.grid
    traction = Vec((0.0, 0.0, model.traction_rate*t))

    for (i, cell) in enumerate(CellIterator(model.dh))
        fill!(re, 0)
        eldofs = celldofs(cell)
        for face in 1:nfaces(cell)
            if (cellid(cell), face) ∈ getfaceset(grid, &quot;right&quot;)
                reinit!(facevalues, cell, face)
                for q_point in 1:getnquadpoints(facevalues)
                    dΓ = getdetJdV(facevalues, q_point)
                    for i in 1:nu
                        δu = shape_value(facevalues, q_point, i)
                        re[i] -= (δu ⋅ traction) * dΓ
                    end
                end
            end
        end
        buf.r[eldofs] .+= re
    end
end;</code></pre><h2 id="Specialized-functions-for-our-problem"><a class="docs-heading-anchor" href="#Specialized-functions-for-our-problem">Specialized functions for our problem</a><a id="Specialized-functions-for-our-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Specialized-functions-for-our-problem" title="Permalink"></a></h2><p>We first define our &quot;get&quot;-functions to get the key arrays for our problem. Note that these functions don&#39;t calculate or update anything, that updating is taken care of by <code>update-update_to_next_step!</code> and <code>update_problem!</code> below.</p><pre><code class="language-julia hljs">FESolvers.getunknowns(p::PlasticityProblem) = p.buf.u;
FESolvers.getresidual(p::PlasticityProblem) = p.buf.r;
FESolvers.getjacobian(p::PlasticityProblem) = p.buf.K;</code></pre><p>We then define the function to update the problem to a different time. This is typically used to set time dependent boundary conditions. Here, it is also possible to make an improved guess for the solution to this time step if desired.</p><pre><code class="language-julia hljs">function FESolvers.update_to_next_step!(p::PlasticityProblem, time)
    p.buf.time .= time
    update!(p.def.ch, time) # No influence in this particular example
end;</code></pre><p>Next, we define the updating of the problem given a new guess to the solution. Note that we use <code>Δu::Nothing</code> for the case it is not given, to signal no change. This version is called directly after update<em>to</em>next_step! before entering the nonlinear iterations.</p><pre><code class="language-julia hljs">function FESolvers.update_problem!(p::PlasticityProblem, Δu, _)
    buf = p.buf
    def = p.def
    if !isnothing(Δu)
        apply_zero!(Δu, p.def.ch)
        buf.u .+= Δu
    end
    doassemble!(buf.cv, buf.fv, buf.K, buf.r,
                def.dh.grid, def.dh, def.material, buf.u, buf.states, buf.states_old)
    apply_neumann!(def,buf)
    apply_zero!(buf.K, buf.r, def.ch)
end;</code></pre><p>In this example, we use the standard convergence criterion that the norm of the free degrees of freedom is less than the iteration tolerance.</p><pre><code class="language-julia hljs">FESolvers.calculate_convergence_measure(p::PlasticityProblem, args...) = norm(FESolvers.getresidual(p)[free_dofs(p.def.ch)]);</code></pre><p>As postprocessing, which is called after we detect that the solution has converged, we save the maximum displacement as well as the traction magnitude.</p><pre><code class="language-julia hljs">function FESolvers.postprocess!(p::PlasticityProblem, solver)
    push!(p.post.umax, maximum(abs, FESolvers.getunknowns(p)))
    push!(p.post.tmag, p.def.traction_rate*p.buf.time[1])
end;</code></pre><p>After convergence (and postprocessing of that step), we also need to update the state variables and the time</p><pre><code class="language-julia hljs">function FESolvers.handle_converged!(p::PlasticityProblem)
    p.buf.states_old .= p.buf.states
    p.buf.old_time .= p.buf.time
end;</code></pre><h2 id="Solving-the-problem"><a class="docs-heading-anchor" href="#Solving-the-problem">Solving the problem</a><a id="Solving-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-problem" title="Permalink"></a></h2><p>First, we define a helper function to plot the results after the solution</p><pre><code class="language-julia hljs">function plot_results(problem; plt=plot(), label, markershape, markersize=4)
    plot!(plt, problem.post.umax, problem.post.tmag,
        linewidth=0.5, title=&quot;Traction-displacement&quot;, label=label,
        markeralpha=0.75, markershape=markershape, markersize=markersize)
    ylabel!(plt, &quot;Traction [Pa]&quot;)
    xlabel!(plt, &quot;Maximum deflection [m]&quot;)
    return plt
end;</code></pre><p>Finally, we can solve the problem with different time stepping strategies and plot the results</p><pre><code class="language-julia hljs">function example_solution()
    def = PlasticityModel()

    # Fixed uniform time steps
    problem = build_problem(def)
    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))
    solve_problem!(problem, solver)
    plt = plot_results(problem, label=&quot;uniform&quot;, markershape=:x, markersize=5)

    # Same time steps as Ferrite example
    problem = build_problem(def)
    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))
    solve_problem!(problem, solver)
    plot_results(problem, plt=plt, label=&quot;fixed&quot;, markershape=:circle)

    # Adaptive time stepping
    problem = build_problem(def)
    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)
    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)
    solve_problem!(problem, solver)
    println(problem.buf.time)
    plot_results(problem, plt=plt, label=&quot;adaptive&quot;, markershape=:circle)
    plot!(;legend=:bottomright)
end;

example_solution()</code></pre><img src="64571c19.svg" alt="Example block output"/><h2 id="Plain-program"><a class="docs-heading-anchor" href="#Plain-program">Plain program</a><a id="Plain-program-1"></a><a class="docs-heading-anchor-permalink" href="#Plain-program" title="Permalink"></a></h2><p>Here follows a version of the program without any comments. The file is also available here: <a href="../plasticity.jl"><code>plasticity.jl</code></a>.</p><pre><code class="language-julia hljs">using FESolvers, Ferrite, Tensors, SparseArrays, LinearAlgebra, Plots

include(&quot;plasticity_definitions.jl&quot;);

struct PlasticityProblem{PD,PB,PP}
    def::PD
    buf::PB
    post::PP
end

struct PlasticityModel{DH,CH,IP,M}
    dh::DH
    ch::CH
    interpolation::IP
    material::M
    traction_rate::Float64
end

function PlasticityModel()
    # Material
    E = 200.0e9; ν = 0.3    # Young&#39;s modulus and Poisson&#39;s ratio
    σ₀ = 200e6; H = E/20    # Yield limit and hardening modulus
    material = J2Plasticity(E, ν, σ₀, H)

    # Geometry (length, width, height)
    L = 10.0; w = 1.0; h = 1.0

    # Loading
    traction_rate = 1.e7    # N/s

    # Grid (beam)
    nels = (20, 2, 4)
    grid = generate_grid(Tetrahedron, nels, zero(Vec{3}), Vec((L, w, h)))

    # Interpolation and DofHandler
    ip = Lagrange{3, RefTetrahedron, 1}()
    dh = DofHandler(grid)
    add!(dh, :u, 3, ip)
    close!(dh)

    # ConstraintHandler
    ch = ConstraintHandler(dh)
    add!(ch, Dirichlet(:u, getfaceset(grid, &quot;left&quot;), Returns(zeros(3))))
    close!(ch)
    return PlasticityModel(dh, ch, ip, material, traction_rate)
end;

struct PlasticityFEBuffer{CV,FV,KT,T,ST}
    cv::CV          # CellValues
    fv::FV          # FaceValues
    K::KT           # Stiffness matrix
    r::Vector{T}    # Residual vector
    u::Vector{T}    # Unknown vector
    states::Matrix{ST}
    states_old::Matrix{ST}
    time::Vector{T}     # Just a vector to allow mutating the time
    old_time::Vector{T} # Same as time (not needed, but shown for completeness)
end

function build_febuffer(model::PlasticityModel)
    dh = model.dh
    n_dofs = ndofs(dh)
    qr      = QuadratureRule{3,RefTetrahedron}(2)
    face_qr = QuadratureRule{2,RefTetrahedron}(3)
    ip_geo = Ferrite.default_interpolation(Ferrite.getcelltype(dh.grid))
    cv = CellVectorValues(qr, model.interpolation, ip_geo)
    fv = FaceVectorValues(face_qr, model.interpolation, ip_geo)
    u  = zeros(n_dofs)
    r = zeros(n_dofs)
    K = create_sparsity_pattern(dh)
    nqp = getnquadpoints(cv)
    states = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.dh.grid)]
    states_old = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.dh.grid)]
    return PlasticityFEBuffer(cv,fv,K,r,u,states,states_old,[0.0], [0.0])
end;

struct PlasticityPost{T}
    umax::Vector{T}
    tmag::Vector{T}
end
PlasticityPost() = PlasticityPost(Float64[],Float64[]);

build_problem(def::PlasticityModel) = PlasticityProblem(def, build_febuffer(def), PlasticityPost());

function apply_neumann!(model::PlasticityModel,buf::PlasticityFEBuffer)
    t = buf.time[1]
    nu = getnbasefunctions(buf.cv)
    re = zeros(nu)
    facevalues = buf.fv
    grid = model.dh.grid
    traction = Vec((0.0, 0.0, model.traction_rate*t))

    for (i, cell) in enumerate(CellIterator(model.dh))
        fill!(re, 0)
        eldofs = celldofs(cell)
        for face in 1:nfaces(cell)
            if (cellid(cell), face) ∈ getfaceset(grid, &quot;right&quot;)
                reinit!(facevalues, cell, face)
                for q_point in 1:getnquadpoints(facevalues)
                    dΓ = getdetJdV(facevalues, q_point)
                    for i in 1:nu
                        δu = shape_value(facevalues, q_point, i)
                        re[i] -= (δu ⋅ traction) * dΓ
                    end
                end
            end
        end
        buf.r[eldofs] .+= re
    end
end;

FESolvers.getunknowns(p::PlasticityProblem) = p.buf.u;
FESolvers.getresidual(p::PlasticityProblem) = p.buf.r;
FESolvers.getjacobian(p::PlasticityProblem) = p.buf.K;

function FESolvers.update_to_next_step!(p::PlasticityProblem, time)
    p.buf.time .= time
    update!(p.def.ch, time) # No influence in this particular example
end;

function FESolvers.update_problem!(p::PlasticityProblem, Δu, _)
    buf = p.buf
    def = p.def
    if !isnothing(Δu)
        apply_zero!(Δu, p.def.ch)
        buf.u .+= Δu
    end
    doassemble!(buf.cv, buf.fv, buf.K, buf.r,
                def.dh.grid, def.dh, def.material, buf.u, buf.states, buf.states_old)
    apply_neumann!(def,buf)
    apply_zero!(buf.K, buf.r, def.ch)
end;

FESolvers.calculate_convergence_measure(p::PlasticityProblem, args...) = norm(FESolvers.getresidual(p)[free_dofs(p.def.ch)]);

function FESolvers.postprocess!(p::PlasticityProblem, solver)
    push!(p.post.umax, maximum(abs, FESolvers.getunknowns(p)))
    push!(p.post.tmag, p.def.traction_rate*p.buf.time[1])
end;

function FESolvers.handle_converged!(p::PlasticityProblem)
    p.buf.states_old .= p.buf.states
    p.buf.old_time .= p.buf.time
end;

function plot_results(problem; plt=plot(), label, markershape, markersize=4)
    plot!(plt, problem.post.umax, problem.post.tmag,
        linewidth=0.5, title=&quot;Traction-displacement&quot;, label=label,
        markeralpha=0.75, markershape=markershape, markersize=markersize)
    ylabel!(plt, &quot;Traction [Pa]&quot;)
    xlabel!(plt, &quot;Maximum deflection [m]&quot;)
    return plt
end;

function example_solution()
    def = PlasticityModel()

    # Fixed uniform time steps
    problem = build_problem(def)
    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))
    solve_problem!(problem, solver)
    plt = plot_results(problem, label=&quot;uniform&quot;, markershape=:x, markersize=5)

    # Same time steps as Ferrite example
    problem = build_problem(def)
    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))
    solve_problem!(problem, solver)
    plot_results(problem, plt=plt, label=&quot;fixed&quot;, markershape=:circle)

    # Adaptive time stepping
    problem = build_problem(def)
    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)
    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)
    solve_problem!(problem, solver)
    println(problem.buf.time)
    plot_results(problem, plt=plt, label=&quot;adaptive&quot;, markershape=:circle)
    plot!(;legend=:bottomright)
end;

example_solution()

# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../linearsolvers/">« Linear solvers</a><a class="docs-footer-nextpage" href="../transient_heat/">Linear Time Dependent Problem »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Tuesday 27 May 2025 15:43">Tuesday 27 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
