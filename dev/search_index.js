var documenterSearchIndex = {"docs":
[{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"../literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example is based on Ferrite.jl's plasticity example and modified to show how FESolvers can be used to solve this nonlinear problem with time dependent loading.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"note: Note\nThis example is preliminary, and doesn't necessarily represent good coding practice. As an example of a more general implementation, please see FerriteProblems.jl and its example","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First we need to load all required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using FESolvers, Ferrite, Tensors, SparseArrays, LinearAlgebra, Plots","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We first include some basic definitions taken and modified from the original example, specifically the material definitions: J2Plasticity and J2PlasticityMaterialState, as well as the doassemble! function. The exact definitions are available here: plasticity_definitions.jl,","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"include(\"plasticity_definitions.jl\");\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Problem-definition","page":"Plasticity","title":"Problem definition","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We divide the problem struct into three parts: definitions (def), a buffer (buf), and postprocessing (post) to structure the information and make it easier to save the simulation settings (enough to save def as the others will be created based on this one)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityProblem{PD,PB,PP}\n    def::PD\n    buf::PB\n    post::PP\nend","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"PlasticityModel is our def and contain all problem settings (mesh, material, loads, interpolations, etc.)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityModel{DH,CH,IP,M}\n    dh::DH\n    ch::CH\n    interpolation::IP\n    material::M\n    traction_rate::Float64\nend\n\nfunction PlasticityModel()\n    # Material\n    E = 200.0e9; ν = 0.3    # Young's modulus and Poisson's ratio\n    σ₀ = 200e6; H = E/20    # Yield limit and hardening modulus\n    material = J2Plasticity(E, ν, σ₀, H)\n\n    # Geometry (length, width, height)\n    L = 10.0; w = 1.0; h = 1.0\n\n    # Loading\n    traction_rate = 1.e7    # N/s\n\n    # Grid (beam)\n    nels = (20, 2, 4)\n    grid = generate_grid(Tetrahedron, nels, zero(Vec{3}), Vec((L, w, h)))\n\n    # Interpolation and DofHandler\n    ip = Lagrange{3, RefTetrahedron, 1}()\n    dh = DofHandler(grid)\n    add!(dh, :u, 3, ip)\n    close!(dh)\n\n    # ConstraintHandler\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), Returns(zeros(3))))\n    close!(ch)\n    return PlasticityModel(dh, ch, ip, material, traction_rate)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"PlasticityFEBuffer is our buf and contains all problem arrays and other allocated values","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityFEBuffer{CV,FV,KT,T,ST}\n    cv::CV          # CellValues\n    fv::FV          # FaceValues\n    K::KT           # Stiffness matrix\n    r::Vector{T}    # Residual vector\n    u::Vector{T}    # Unknown vector\n    states::Matrix{ST}\n    states_old::Matrix{ST}\n    time::Vector{T}     # Just a vector to allow mutating the time\n    old_time::Vector{T} # Same as time (not needed, but shown for completeness)\nend\n\nfunction build_febuffer(model::PlasticityModel)\n    dh = model.dh\n    n_dofs = ndofs(dh)\n    qr      = QuadratureRule{3,RefTetrahedron}(2)\n    face_qr = QuadratureRule{2,RefTetrahedron}(3)\n    ip_geo = Ferrite.default_interpolation(Ferrite.getcelltype(dh.grid))\n    cv = CellVectorValues(qr, model.interpolation, ip_geo)\n    fv = FaceVectorValues(face_qr, model.interpolation, ip_geo)\n    u  = zeros(n_dofs)\n    r = zeros(n_dofs)\n    K = create_sparsity_pattern(dh)\n    nqp = getnquadpoints(cv)\n    states = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.dh.grid)]\n    states_old = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.dh.grid)]\n    return PlasticityFEBuffer(cv,fv,K,r,u,states,states_old,[0.0], [0.0])\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, we define our post that contains variables that we will save during the simulation","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityPost{T}\n    umax::Vector{T}\n    tmag::Vector{T}\nend\nPlasticityPost() = PlasticityPost(Float64[],Float64[]);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"To facilitate reuse, we define a function that gives our full problem struct based on the problem definition","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"build_problem(def::PlasticityModel) = PlasticityProblem(def, build_febuffer(def), PlasticityPost());\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Neumann-boundary-conditions","page":"Plasticity","title":"Neumann boundary conditions","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We then define a separate function for the Neumann boundary conditions (note that this difference to the original example is not required, but only to separate the element assembly and external boundary conditions) This could also be further simplified by using FerriteNeumann.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function apply_neumann!(model::PlasticityModel,buf::PlasticityFEBuffer)\n    t = buf.time[1]\n    nu = getnbasefunctions(buf.cv)\n    re = zeros(nu)\n    facevalues = buf.fv\n    grid = model.dh.grid\n    traction = Vec((0.0, 0.0, model.traction_rate*t))\n\n    for (i, cell) in enumerate(CellIterator(model.dh))\n        fill!(re, 0)\n        eldofs = celldofs(cell)\n        for face in 1:nfaces(cell)\n            if (cellid(cell), face) ∈ getfaceset(grid, \"right\")\n                reinit!(facevalues, cell, face)\n                for q_point in 1:getnquadpoints(facevalues)\n                    dΓ = getdetJdV(facevalues, q_point)\n                    for i in 1:nu\n                        δu = shape_value(facevalues, q_point, i)\n                        re[i] -= (δu ⋅ traction) * dΓ\n                    end\n                end\n            end\n        end\n        buf.r[eldofs] .+= re\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Specialized-functions-for-our-problem","page":"Plasticity","title":"Specialized functions for our problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We first define our \"get\"-functions to get the key arrays for our problem. Note that these functions don't calculate or update anything, that updating is taken care of by update-update_to_next_step! and update_problem! below.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"FESolvers.getunknowns(p::PlasticityProblem) = p.buf.u;\nFESolvers.getresidual(p::PlasticityProblem) = p.buf.r;\nFESolvers.getjacobian(p::PlasticityProblem) = p.buf.K;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We then define the function to update the problem to a different time. This is typically used to set time dependent boundary conditions. Here, it is also possible to make an improved guess for the solution to this time step if desired.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.update_to_next_step!(p::PlasticityProblem, time)\n    p.buf.time .= time\n    update!(p.def.ch, time) # No influence in this particular example\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Next, we define the updating of the problem given a new guess to the solution. Note that we use Δu::Nothing for the case it is not given, to signal no change. This version is called directly after updatetonext_step! before entering the nonlinear iterations.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.update_problem!(p::PlasticityProblem, Δu, _)\n    buf = p.buf\n    def = p.def\n    if !isnothing(Δu)\n        apply_zero!(Δu, p.def.ch)\n        buf.u .+= Δu\n    end\n    doassemble!(buf.cv, buf.fv, buf.K, buf.r,\n                def.dh.grid, def.dh, def.material, buf.u, buf.states, buf.states_old)\n    apply_neumann!(def,buf)\n    apply_zero!(buf.K, buf.r, def.ch)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"In this example, we use the standard convergence criterion that the norm of the free degrees of freedom is less than the iteration tolerance.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"FESolvers.calculate_convergence_measure(p::PlasticityProblem, args...) = norm(FESolvers.getresidual(p)[free_dofs(p.def.ch)]);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"As postprocessing, which is called after we detect that the solution has converged, we save the maximum displacement as well as the traction magnitude.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.postprocess!(p::PlasticityProblem, solver)\n    push!(p.post.umax, maximum(abs, FESolvers.getunknowns(p)))\n    push!(p.post.tmag, p.def.traction_rate*p.buf.time[1])\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"After convergence (and postprocessing of that step), we also need to update the state variables and the time","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.handle_converged!(p::PlasticityProblem)\n    p.buf.states_old .= p.buf.states\n    p.buf.old_time .= p.buf.time\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Solving-the-problem","page":"Plasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First, we define a helper function to plot the results after the solution","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function plot_results(problem; plt=plot(), label, markershape, markersize=4)\n    plot!(plt, problem.post.umax, problem.post.tmag,\n        linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, we can solve the problem with different time stepping strategies and plot the results","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function example_solution()\n    def = PlasticityModel()\n\n    # Fixed uniform time steps\n    problem = build_problem(def)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    solve_problem!(problem, solver)\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example\n    problem = build_problem(def)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    solve_problem!(problem, solver)\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping\n    problem = build_problem(def)\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    solve_problem!(problem, solver)\n    println(problem.buf.time)\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n    plot!(;legend=:bottomright)\nend;\n\nexample_solution()","category":"page"},{"location":"examples/plasticity/#Plain-program","page":"Plasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Here follows a version of the program without any comments. The file is also available here: plasticity.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using FESolvers, Ferrite, Tensors, SparseArrays, LinearAlgebra, Plots\n\ninclude(\"plasticity_definitions.jl\");\n\nstruct PlasticityProblem{PD,PB,PP}\n    def::PD\n    buf::PB\n    post::PP\nend\n\nstruct PlasticityModel{DH,CH,IP,M}\n    dh::DH\n    ch::CH\n    interpolation::IP\n    material::M\n    traction_rate::Float64\nend\n\nfunction PlasticityModel()\n    # Material\n    E = 200.0e9; ν = 0.3    # Young's modulus and Poisson's ratio\n    σ₀ = 200e6; H = E/20    # Yield limit and hardening modulus\n    material = J2Plasticity(E, ν, σ₀, H)\n\n    # Geometry (length, width, height)\n    L = 10.0; w = 1.0; h = 1.0\n\n    # Loading\n    traction_rate = 1.e7    # N/s\n\n    # Grid (beam)\n    nels = (20, 2, 4)\n    grid = generate_grid(Tetrahedron, nels, zero(Vec{3}), Vec((L, w, h)))\n\n    # Interpolation and DofHandler\n    ip = Lagrange{3, RefTetrahedron, 1}()\n    dh = DofHandler(grid)\n    add!(dh, :u, 3, ip)\n    close!(dh)\n\n    # ConstraintHandler\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfaceset(grid, \"left\"), Returns(zeros(3))))\n    close!(ch)\n    return PlasticityModel(dh, ch, ip, material, traction_rate)\nend;\n\nstruct PlasticityFEBuffer{CV,FV,KT,T,ST}\n    cv::CV          # CellValues\n    fv::FV          # FaceValues\n    K::KT           # Stiffness matrix\n    r::Vector{T}    # Residual vector\n    u::Vector{T}    # Unknown vector\n    states::Matrix{ST}\n    states_old::Matrix{ST}\n    time::Vector{T}     # Just a vector to allow mutating the time\n    old_time::Vector{T} # Same as time (not needed, but shown for completeness)\nend\n\nfunction build_febuffer(model::PlasticityModel)\n    dh = model.dh\n    n_dofs = ndofs(dh)\n    qr      = QuadratureRule{3,RefTetrahedron}(2)\n    face_qr = QuadratureRule{2,RefTetrahedron}(3)\n    ip_geo = Ferrite.default_interpolation(Ferrite.getcelltype(dh.grid))\n    cv = CellVectorValues(qr, model.interpolation, ip_geo)\n    fv = FaceVectorValues(face_qr, model.interpolation, ip_geo)\n    u  = zeros(n_dofs)\n    r = zeros(n_dofs)\n    K = create_sparsity_pattern(dh)\n    nqp = getnquadpoints(cv)\n    states = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.dh.grid)]\n    states_old = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.dh.grid)]\n    return PlasticityFEBuffer(cv,fv,K,r,u,states,states_old,[0.0], [0.0])\nend;\n\nstruct PlasticityPost{T}\n    umax::Vector{T}\n    tmag::Vector{T}\nend\nPlasticityPost() = PlasticityPost(Float64[],Float64[]);\n\nbuild_problem(def::PlasticityModel) = PlasticityProblem(def, build_febuffer(def), PlasticityPost());\n\nfunction apply_neumann!(model::PlasticityModel,buf::PlasticityFEBuffer)\n    t = buf.time[1]\n    nu = getnbasefunctions(buf.cv)\n    re = zeros(nu)\n    facevalues = buf.fv\n    grid = model.dh.grid\n    traction = Vec((0.0, 0.0, model.traction_rate*t))\n\n    for (i, cell) in enumerate(CellIterator(model.dh))\n        fill!(re, 0)\n        eldofs = celldofs(cell)\n        for face in 1:nfaces(cell)\n            if (cellid(cell), face) ∈ getfaceset(grid, \"right\")\n                reinit!(facevalues, cell, face)\n                for q_point in 1:getnquadpoints(facevalues)\n                    dΓ = getdetJdV(facevalues, q_point)\n                    for i in 1:nu\n                        δu = shape_value(facevalues, q_point, i)\n                        re[i] -= (δu ⋅ traction) * dΓ\n                    end\n                end\n            end\n        end\n        buf.r[eldofs] .+= re\n    end\nend;\n\nFESolvers.getunknowns(p::PlasticityProblem) = p.buf.u;\nFESolvers.getresidual(p::PlasticityProblem) = p.buf.r;\nFESolvers.getjacobian(p::PlasticityProblem) = p.buf.K;\n\nfunction FESolvers.update_to_next_step!(p::PlasticityProblem, time)\n    p.buf.time .= time\n    update!(p.def.ch, time) # No influence in this particular example\nend;\n\nfunction FESolvers.update_problem!(p::PlasticityProblem, Δu, _)\n    buf = p.buf\n    def = p.def\n    if !isnothing(Δu)\n        apply_zero!(Δu, p.def.ch)\n        buf.u .+= Δu\n    end\n    doassemble!(buf.cv, buf.fv, buf.K, buf.r,\n                def.dh.grid, def.dh, def.material, buf.u, buf.states, buf.states_old)\n    apply_neumann!(def,buf)\n    apply_zero!(buf.K, buf.r, def.ch)\nend;\n\nFESolvers.calculate_convergence_measure(p::PlasticityProblem, args...) = norm(FESolvers.getresidual(p)[free_dofs(p.def.ch)]);\n\nfunction FESolvers.postprocess!(p::PlasticityProblem, solver)\n    push!(p.post.umax, maximum(abs, FESolvers.getunknowns(p)))\n    push!(p.post.tmag, p.def.traction_rate*p.buf.time[1])\nend;\n\nfunction FESolvers.handle_converged!(p::PlasticityProblem)\n    p.buf.states_old .= p.buf.states\n    p.buf.old_time .= p.buf.time\nend;\n\nfunction plot_results(problem; plt=plot(), label, markershape, markersize=4)\n    plot!(plt, problem.post.umax, problem.post.tmag,\n        linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\n\nfunction example_solution()\n    def = PlasticityModel()\n\n    # Fixed uniform time steps\n    problem = build_problem(def)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    solve_problem!(problem, solver)\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example\n    problem = build_problem(def)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    solve_problem!(problem, solver)\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping\n    problem = build_problem(def)\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    solve_problem!(problem, solver)\n    println(problem.buf.time)\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n    plot!(;legend=:bottomright)\nend;\n\nexample_solution()\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"NOTE: THIS PAGE IS NOT IN USE, BUT SHOULD BE POPULATED IF MORE SOLVERS ARE IMPLEMENTED","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Solvers are the top level object in this package,  each solver should define the function solve_problem!","category":"page"},{"location":"solvers/#Implemented-Solvers","page":"Solvers","title":"Implemented Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"QuasiStaticSolver","category":"page"},{"location":"nlsolvers/#Nonlinear-solvers","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"NewtonSolver\nFESolvers.AdaptiveNewtonSolver\nSteepestDescent\nLinearProblemSolver\nFESolvers.DynamicSolver\nFESolvers.MultiStageSolver","category":"page"},{"location":"nlsolvers/#FESolvers.NewtonSolver","page":"Nonlinear solvers","title":"FESolvers.NewtonSolver","text":"NewtonSolver(;\n    linsolver=BackslashSolver(), linesearch=NoLineSearch(), \n    maxiter=10, tolerance=1.e-6,\n    update_jac_first=true, update_jac_each=true)\n\nUse the standard Newton-Raphson solver to solve the nonlinear  problem r(x) = 0 with tolerance within the maximum number  of iterations maxiter. \n\nQuasi-Newton methods\n\nLinesearch: The linsolver argument determines the used linear solver whereas the linesearch can be set currently between NoLineSearch or ArmijoGoldstein. The latter globalizes the Newton strategy.\n\n**Jacobian updates: ** The keyword update_jac_first decides if the jacobian from the previously converged time step should be updated after calling update_to_next_step!, or to use the old.  Setting update_jac_each implies that the jacobian will not be updated during the iterations. If both update_jac_each and update_jac_first are false, the initial jacobian will be used  throughout. Note that these keywords require that the problem respects the update_jacobian keyword given to update_problem!. For time-independent problems or time-depdent problems with  constant time steps, update_jac_first=false is often a good choice.  However, for time-dependent problems with changing time step length,  the standard solver (default), may work better. \n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.AdaptiveNewtonSolver","page":"Nonlinear solvers","title":"FESolvers.AdaptiveNewtonSolver","text":"AdaptiveNewtonSolver(;\n    update_types, switch_criterion,\n    linsolver=BackslashSolver(), linesearch=NoLineSearch(),\n    maxiter=10, tolerance=1e-6, update_jac_first=true)\n\nDefine an adaptive newton solver, where the update type  (given to UpdateSpec) changes during the iterations. The different options  are given to update_types, and the criterion to switch  between them is given to switch_criterion. Remaining options are similar to the standard newton solver. \n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.SteepestDescent","page":"Nonlinear solvers","title":"FESolvers.SteepestDescent","text":"SteepestDescent(;maxiter=10, tolerance=1.e-6)\n\nUse a steepest descent solver to solve the nonlinear  problem r(x) = 0, which minimizes a potential Pi with tolerance and the maximum number of iterations maxiter.\n\nThis method is second derivative free and is not as locally limited as a Newton-Raphson scheme. Thus, it is especially suited for strongly nonlinear behavior with potentially vanishing tangent stiffnesses. For this method, it is required to implement getdescentpreconditioner or alternatively getsystemmatrix with SteepestDescent. \n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.LinearProblemSolver","page":"Nonlinear solvers","title":"FESolvers.LinearProblemSolver","text":"LinearProblemSolver(;linsolver=BackslashSolver())\n\nThis is a special type of \"Nonlinear solver\", which actually only solves linear problems,  but allows all other features (i.e. time stepping and postprocessing) of the FESolvers  package to be used. In particular, it allows you to maintain all other parts of your problem  exactly the same as for a nonlinear problem, but it is possible to get better performance as  it is, in principle, not necessary to assemble twice in each time step. \n\nThis solver is specialized for linear problems of the form\n\nboldsymbolr(boldsymbolx(t)t)=boldsymbolK(t) boldsymbolx(t) - boldsymbolf(t)\n\nwhere boldsymbolK=partial boldsymbolrpartial boldsymbolx.  It expects that boldsymbolx(t) and boldsymbolr(t) have been updated to  boldsymbolx_mathrmbc and boldsymbolr_mathrmbc=boldsymbolK(t)boldsymbolx_mathrmbc-boldsymbolf(t), such that \n\nboldsymbolx(t) = boldsymbolx_mathrmbc - boldsymbolK^-1(t)boldsymbolr_mathrmbc\n= boldsymbolx_mathrmbc - boldsymbolK^-1(t)leftboldsymbolK(t)boldsymbolx_mathrmbc-boldsymbolf(t)right\n= boldsymbolK^-1(t)boldsymbolf(t)\n\nis the solution to the current time step. This normally implies when using Ferrite the same procedure as for nonlinear problems, i.e.  that the boundary conditions are applied in update_to_next_step! and update_problem!, as well as the calculation of the residual  according to above and that apply_zero!(K,r,ch) is called (on both the residual and the stiffness matrix).\n\nIf you have strange results when running the LinearProblemSolver,  please ensure that the problem converges in one iteration for the NewtonSolver\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.DynamicSolver","page":"Nonlinear solvers","title":"FESolvers.DynamicSolver","text":"DynamicSolver(nlsolver, updater)\n\nDynamicSolver contains a base nlsolver that must support set_update_type! such that  the value of type in UpdateSpec can be changed dynamically. This is typically used to change regularization factors for the jacobian calculation. updater should be a function with the  signature type, reset, finished = updater(nlsolver, num_attempts),  where type is given to UpdateSpec in nlsolver, reset says if the problem should be reset, and finished tells if this is the last update that can be done (and if not converged then, it will fail). The inputs are the current nlsolver as well as the number of attempts. \n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.MultiStageSolver","page":"Nonlinear solvers","title":"FESolvers.MultiStageSolver","text":"MultiStageSolver\n\nSolve a problem with multiple stages of nonlinear solvers, switching when each solver  finishes.\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#Further-details-on-selected-solvers","page":"Nonlinear solvers","title":"Further details on selected solvers","text":"","category":"section"},{"location":"nlsolvers/#AdaptiveNewtonSolver","page":"Nonlinear solvers","title":"AdaptiveNewtonSolver","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"For the adaptive newton solver, a few basic switchers have been implemented.","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.NumIterSwitch\nFESolvers.ToleranceSwitch\nFESolvers.IncreaseSwitch","category":"page"},{"location":"nlsolvers/#FESolvers.NumIterSwitch","page":"Nonlinear solvers","title":"FESolvers.NumIterSwitch","text":"NumIterSwitch(;switch_after)\n\nSwitch to update_types[2] after switch_after iterations with update_types[1]\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.ToleranceSwitch","page":"Nonlinear solvers","title":"FESolvers.ToleranceSwitch","text":"ToleranceSwitch(;switch_at)\n\nUse update_types[1] when the convergence measure is larger than switch_at. When the convergence measure is below switch_at,  use update_types[2]. If the convergence measure increases above  switch_at again, reset the problem and change to update_types[1] iterations with update_types[1].\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.IncreaseSwitch","page":"Nonlinear solvers","title":"FESolvers.IncreaseSwitch","text":"IncreaseSwitch(;num_slow)\n\nUse the (typically) fast but less stable update_types[1] as long  as the convergence measure is decreasing. If it starts increasing,  switch to the (typically) slower but more stable update_types[2]. Use this for num_slow iterations after the convergence measure  starts to decrease again.\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"To implement a custom switcher for AdaptiveNewtonSolver, define a new struct and the function switch_information for that struct:","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.switch_information","category":"page"},{"location":"nlsolvers/#FESolvers.switch_information","page":"Nonlinear solvers","title":"FESolvers.switch_information","text":"switch_information(switch_criterion, nlsolver)\n\nCreate a custom switch_criterion by overloading this function, which given the defined switch_criterion and the nlsolver, should return reset_problem::Bool and new_nr::Int, which  determines if the problem should be reset to the state before its  last update and which update_type should be used next, respectively.\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#Problem-update-specification","page":"Nonlinear solvers","title":"Problem update specification","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"An UpdateSpec, which can be querried for information, is passed to update_problem! to give instructions on  how to update the problem. ","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.UpdateSpec","category":"page"},{"location":"nlsolvers/#FESolvers.UpdateSpec","page":"Nonlinear solvers","title":"FESolvers.UpdateSpec","text":"UpdateSpec(;jacobian, residual, type=nothing)\n\nAn UpdateSpec is sent to update_problem! to pass the problem information about how it should be updated. The following methods  should be used by the problem to request information\n\nshould_update_jacobian(::UpdateSpec)::Bool: Self explanatory\nshould_update_residual(::UpdateSpec)::Bool: Self explanatory\nget_update_type(::UpdateSpec): How should the problem be updated? This is used by special solvers where, for example, different  approximations of the stiffness is available, see e.g.  AdaptiveNewtonSolver\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#Custom-solvers","page":"Nonlinear solvers","title":"Custom solvers","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"A custom nonlinear solver can be written by tapping into the existing functions  at different levels. For example, LinearProblemSolver defines a custom  solve_nonlinear! that uses the  default calculate_update!.","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"All nonlinear solvers are expected to implement the following methods,","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.get_max_iter\nFESolvers.get_tolerance\nFESolvers.get_initial_update_spec\nFESolvers.get_solver_state\nFESolvers.update_solver_state!\nFESolvers.reset_solver_state!","category":"page"},{"location":"nlsolvers/#FESolvers.get_max_iter","page":"Nonlinear solvers","title":"FESolvers.get_max_iter","text":"get_max_iter(nlsolver)\n\nReturns the maximum number of iterations allowed for the nonlinear solver\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.get_tolerance","page":"Nonlinear solvers","title":"FESolvers.get_tolerance","text":"get_tolerance(nlsolver)\n\nReturns the iteration tolerance for the solver\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.get_initial_update_spec","page":"Nonlinear solvers","title":"FESolvers.get_initial_update_spec","text":"get_initial_update_spec(nlsolver)::UpdateSpec\n\nHow to update initially (before starting time stepping)\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.get_solver_state","page":"Nonlinear solvers","title":"FESolvers.get_solver_state","text":"get_solver_state(nlsolver)\n\nAll nonlinear solvers that contain a SolverState should normally overload  this function to make many other functions work automatically. \n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.update_solver_state!","page":"Nonlinear solvers","title":"FESolvers.update_solver_state!","text":"update_solver_state!(nlsolver, problem, r)\n\nAllows nonlinear solvers to store information about its convergence state, r is the output from calculate_convergence_measure. \n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.reset_solver_state!","page":"Nonlinear solvers","title":"FESolvers.reset_solver_state!","text":"reset_solver_state!(nlsolver)\n\nCalled at the beginning of each new time step, and resets the  solver's status and potentially convergence history etc. \n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#get_solver_state","page":"Nonlinear solvers","title":"get_solver_state","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"If get_solver_state is not implemented, the following methods must be implemented instead","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.is_converged\nFESolvers.get_num_iter\nFESolvers.get_convergence_measure","category":"page"},{"location":"nlsolvers/#FESolvers.is_converged","page":"Nonlinear solvers","title":"FESolvers.is_converged","text":"is_converged(nlsolver)\n\nHas the nlsolver converged? Reset by reset_solver_state!.\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.get_num_iter","page":"Nonlinear solvers","title":"FESolvers.get_num_iter","text":"get_num_iter(nlsolver)\n\nReturns the last number of iterations used by the nonlinear solver\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.get_convergence_measure","page":"Nonlinear solvers","title":"FESolvers.get_convergence_measure","text":"get_convergence_measure(nlsolver)\n\nGet the last convergence measure for nlsolver. \n\nget_convergence_measure(nlsolver, k::Integer)\n\nGet the kth convergence measure in the current iteration\n\nget_convergence_measure(nlsolver, inds)\n\nGet a view to the vector of the convergence measures for  iterations inds, i.e. view(residuals, inds)\n\nget_convergence_measure(nlsolver, ::Colon)\n\nGet a view to the vector of all convergence measures, i.e.  get_convergence_measure(nlsolver, 1:get_num_iter(nlsolver))\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#Methods-required-by-solve_nonlinear!","page":"Nonlinear solvers","title":"Methods required by solve_nonlinear!","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"After implementing the methods above, one can either implement solve_nonlinear!, or a set of method described below to use the default implementation.","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.solve_nonlinear!","category":"page"},{"location":"nlsolvers/#FESolvers.solve_nonlinear!","page":"Nonlinear solvers","title":"FESolvers.solve_nonlinear!","text":"solve_nonlinear!(problem, nlsolver, last_converged)\n\nSolve the current time step in the nonlinear problem, (r(x) = 0), by using the nonlinear solver nlsolver. last_converged::Bool  is just for information if the last time step converged or not.  In many cases it suffices to overload calculate_update!  for a custom nonlinear solver. \n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"To use the default implementation of solve_nonlinear!, calculate_update! and the other methods in the list below must be implemented for the specific nonlinear solver.  The default implementation of calculate_update! may be used as well, see the description below.","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.calculate_update!\nFESolvers.get_first_update_spec\nFESolvers.get_update_spec\nFESolvers.should_reset_problem","category":"page"},{"location":"nlsolvers/#FESolvers.calculate_update!","page":"Nonlinear solvers","title":"FESolvers.calculate_update!","text":"function calculate_update!(Δx, problem, nlsolver)\n\nAccording to the nonlinear solver, nlsolver, at iteration iter, calculate the update, Δx to the unknowns x.\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.get_first_update_spec","page":"Nonlinear solvers","title":"FESolvers.get_first_update_spec","text":"get_first_update_spec(nlsolver)::UpdateSpec\n\nGet the update specification for nlsolver in the first iteration of the time step.\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.get_update_spec","page":"Nonlinear solvers","title":"FESolvers.get_update_spec","text":"get_update_spec(nlsolver)::UpdateSpec\n\nGet the update specification during regular iterations. It is the nlsolver's job  to keep track of any state required for deciding changes to the update specification  during iterations. \n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.should_reset_problem","page":"Nonlinear solvers","title":"FESolvers.should_reset_problem","text":"should_reset_problem(nlsolver)\n\nNote: Custom nonlinear solvers may rely on the default false return value.\n\nIf this function returns true, the problem will be reset as update_problem!(problem, -Δa) to reset the problem to the state  at the last iteration (e.g. when switching the jacobian calculation)\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#Methods-required-by-calculate_update!","page":"Nonlinear solvers","title":"Methods required by calculate_update!","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"To support the default calculate_update! implementation,  the following methods must be implemented for the given solver. ","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.get_linear_solver\nFESolvers.get_linesearch","category":"page"},{"location":"nlsolvers/#FESolvers.get_linear_solver","page":"Nonlinear solvers","title":"FESolvers.get_linear_solver","text":"get_linear_solver(nlsolver)\n\nGet the linear solver used by the nonlinear solver\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.get_linesearch","page":"Nonlinear solvers","title":"FESolvers.get_linesearch","text":"get_linesearch(nlsolver)\n\nReturns the used linesearch of the nonlinear solver.\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#Additional-methods-that-usually-don't-require-specialization","page":"Nonlinear solvers","title":"Additional methods that usually don't require specialization","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.should_do_initial_update\nFESolvers.reset_problem!","category":"page"},{"location":"nlsolvers/#FESolvers.should_do_initial_update","page":"Nonlinear solvers","title":"FESolvers.should_do_initial_update","text":"should_do_initial_update(nlsolver)\n\nShould the problem be updated initially, before starting time stepping? Normally, not required to overload as the update specification from  get_initial_update_spec is used to decide how if an update is required. \n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.reset_problem!","page":"Nonlinear solvers","title":"FESolvers.reset_problem!","text":"reset_problem!(problem, nlsolver; x, Δx_old)\n\nReset the problem, either by giving the new vector of unknown values, x, or the last increment to be reset, Δx_old. x will not be modified if given, but Δx_old will be modified to -Δx_old if given. \n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#Linesearch","page":"Nonlinear solvers","title":"Linesearch","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"Some nonlinear solvers can use linesearch as a complement,  and the following linesearches are included. ","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"NoLineSearch\nArmijoGoldstein","category":"page"},{"location":"nlsolvers/#FESolvers.NoLineSearch","page":"Nonlinear solvers","title":"FESolvers.NoLineSearch","text":"NoLineSearch()\n\nSingleton that does not perform a linesearch when used in a nonlinear solver\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.ArmijoGoldstein","page":"Nonlinear solvers","title":"FESolvers.ArmijoGoldstein","text":"Armijo-Goldstein{T}(;β=0.9,μ=0.01,τ0=1.0,τmin=1e-4)\n\nBacktracking line search based on the Armijo-Goldstein condition\n\nPi(boldsymbolu + tau Deltaboldsymbolu) leq Pi(boldsymbolu) - mutaudeltaPi(boldsymbolu)Delta boldsymbolu\n\nwhere Pi is the potential, tau the stepsize, and deltaPi the residuum.\n\n#Fields\n\nβ::T = 0.9 constant factor that changes the steplength τ in each iteration\nμ::T = 0.01 second constant factor that determines how much the potential needs to decrease additionally\nτ0::T = 1.0 start stepsize \nτmin::T = 1e-4 minimal stepsize\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#Custom-linesearch","page":"Nonlinear solvers","title":"Custom linesearch","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"A custom linesearch should implement the following function","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.linesearch!","category":"page"},{"location":"nlsolvers/#FESolvers.linesearch!","page":"Nonlinear solvers","title":"FESolvers.linesearch!","text":"linesearch!(Δx, problem, ls::AbstractLineSearch)\n\nSearch along Δx to find the minimum of the potential.  Return the modified Δx.\n\n\n\n\n\n","category":"function"},{"location":"linearsolvers/#Linear-solvers","page":"Linear solvers","title":"Linear solvers","text":"","category":"section"},{"location":"linearsolvers/","page":"Linear solvers","title":"Linear solvers","text":"BackslashSolver","category":"page"},{"location":"linearsolvers/#FESolvers.BackslashSolver","page":"Linear solvers","title":"FESolvers.BackslashSolver","text":"BackslashSolver()\n\nThe standard julia linear solver using Δx .= -K\\r\n\n\n\n\n\n","category":"type"},{"location":"linearsolvers/","page":"Linear solvers","title":"Linear solvers","text":"LinearSolve.jl","category":"page"},{"location":"linearsolvers/","page":"Linear solvers","title":"Linear solvers","text":"The linear solvers in LinearSolve.jl are available  if the LinearSolve.jl package is available (implemented via Requires.jl). This also includes their default solver that is supplied setting the linear solver to nothing.  Please see LinearSolve.jl's documentation for different solvers. ","category":"page"},{"location":"linearsolvers/#Custom-linear-solver","page":"Linear solvers","title":"Custom linear solver","text":"","category":"section"},{"location":"linearsolvers/","page":"Linear solvers","title":"Linear solvers","text":"A linear solver should support the solve_linear! function specified below. ","category":"page"},{"location":"linearsolvers/","page":"Linear solvers","title":"Linear solvers","text":"FESolvers.solve_linear!","category":"page"},{"location":"linearsolvers/#FESolvers.solve_linear!","page":"Linear solvers","title":"FESolvers.solve_linear!","text":"solve_linear!(Δx, K, r, linearsolver)\n\nUsing the method specified by linearsolver,  solve K Δx = -r for Δx\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#User-problem","page":"User problem","title":"User problem","text":"","category":"section"},{"location":"userfunctions/","page":"User problem","title":"User problem","text":"The key to using the FESolvers.jl package is to define your  problem. This problem should support a set of functions in order for the solver to solve your problem.  While some functions are always required, some are only required by certain solvers.  Furthermore, a two-level API exist: Simple and advanced.  The simple API does not expose which solver is used, while the advanced API requires you to dispatch on the type of solver. ","category":"page"},{"location":"userfunctions/#Applicable-to-all-solvers","page":"User problem","title":"Applicable to all solvers","text":"","category":"section"},{"location":"userfunctions/","page":"User problem","title":"User problem","text":"FESolvers.getunknowns\nFESolvers.getresidual\nFESolvers.update_to_next_step!\nFESolvers.update_problem!\nFESolvers.handle_converged!\nFESolvers.handle_notconverged!\nFESolvers.postprocess!\nFESolvers.close_problem","category":"page"},{"location":"userfunctions/#FESolvers.getunknowns","page":"User problem","title":"FESolvers.getunknowns","text":"getunknowns(problem)\n\nReturn the current vector of unknown values\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.getresidual","page":"User problem","title":"FESolvers.getresidual","text":"getresidual(problem)\n\nReturn the current residual vector of the problem\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.update_to_next_step!","page":"User problem","title":"FESolvers.update_to_next_step!","text":"update_to_next_step!(problem, time)\n\nUpdate prescribed values, external loads etc. for the given time.\n\nThis function is called in the beginning of each new time step.  Note that for adaptive time stepping, it may be called with a lower  time than the previous time if the solution did not converge.\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.update_problem!","page":"User problem","title":"FESolvers.update_problem!","text":"update_problem!(problem, Δx, update_spec::UpdateSpec)\n\nUpdate the unknowns of the problem by Δx according to update_spec. Note that \n\nSome linear solvers may be inaccurate, and if a modified stiffness is used  to enforce constraints on x, it is good the force Δx=0 on these components inside this function. \nΔx=nothing in the first call after update_to_next_step! in which case, typically, no change of x should be made. Dirichlet boundary conditions are typically updated in update_to_next_step!.\n\nThe update_spec gives the information about what and how to update. See the documentation for UpdateSpec for further details.  This feature is used by some nonlinear solvers to customize the iteration  strategy to speed up or aid convergence. For basic cases when getting started,  this can be ignored and a simple function definition would be \n\nFESolvers.update_problem!(problem, Δx, _)\n\nupdate_problem!(problem, Δx; update_residual::Bool, update_jacobian::Bool)\n\nThe old but now deprecated interface is still available without update_spec. The instructions are here:\n\nAssemble the residual if update_residual=true\nAssemble the jacobian if update_jacobian=true\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.handle_converged!","page":"User problem","title":"FESolvers.handle_converged!","text":"handle_converged!(problem)\n\nDo necessary update operations once it is known that the  problem has converged. E.g., update old values to the current.  Only called after the problem has converged, after postprocess!\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.handle_notconverged!","page":"User problem","title":"FESolvers.handle_notconverged!","text":"handle_notconverged!(problem, solver)\n\nOptional function to make changes to the problem in case it did not converge. If not implemented, this defaults to a no-op.\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.postprocess!","page":"User problem","title":"FESolvers.postprocess!","text":"postprocess!(problem, solver)\n\nPerform any postprocessing at the current time. Called at the beginning of the simulation, and directly after time step converged (right before handle_converged!).\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.close_problem","page":"User problem","title":"FESolvers.close_problem","text":"close_problem(problem)\n\nThis function is called after solving the problem, even if the solution  fails due to an error thrown, for example if the problem doesn't converge.  Use to close any file streams etc. that are open and should be closed\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#Simple-API","page":"User problem","title":"Simple API","text":"","category":"section"},{"location":"userfunctions/","page":"User problem","title":"User problem","text":"FESolvers.calculate_convergence_measure\nFESolvers.getjacobian\nFESolvers.getdescentpreconditioner\nFESolvers.calculate_energy","category":"page"},{"location":"userfunctions/#FESolvers.calculate_convergence_measure","page":"User problem","title":"FESolvers.calculate_convergence_measure","text":"calculate_convergence_measure(problem, Δa, iter) -> AbstractFloat\n\nCalculate a value to be compared with the tolerance of the nonlinear solver.  A standard case when using Ferrite.jl is norm(getresidual(problem)[Ferrite.free_dofs(ch)])  where ch::Ferrite.ConstraintHandler. Δa is the update of the unknowns from  the previous iteration. Note that iter=1 implies Δa=0\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.getjacobian","page":"User problem","title":"FESolvers.getjacobian","text":"getjacobian(problem)\n\nReturn the jacobian drdx, or approximations thereof.\n\nMust be defined for NewtonSolver, but can also be  defined by the advanced API alternative getsystemmatrix:  getsystemmatrix(problem, ::NewtonSolver)\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.getdescentpreconditioner","page":"User problem","title":"FESolvers.getdescentpreconditioner","text":"getdescentpreconditioner(problem)\n\nReturn a preconditioner K for calculating the descent direction p, considering solving r(x)=0 as a minimization problem of f(x) where r=∇f. The descent direction is then p = K⁻¹ ∇f\n\nUsed by the SteepestDescent solver, and defaults to I if not defined.  The advanced API alternative is getsystemmatrix:  getsystemmatrix(problem, ::SteepestDescent)\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.calculate_energy","page":"User problem","title":"FESolvers.calculate_energy","text":"calculate_energy(problem,𝐮)\n\nReturn the energy of the system (a scalar) which is the integrated energy density over the domain Ω.\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#Advanced-API","page":"User problem","title":"Advanced API","text":"","category":"section"},{"location":"userfunctions/","page":"User problem","title":"User problem","text":"FESolvers.getsystemmatrix","category":"page"},{"location":"userfunctions/#FESolvers.getsystemmatrix","page":"User problem","title":"FESolvers.getsystemmatrix","text":"getsystemmatrix(problem,nlsolver)\n\nReturn the system matrix of the problem. For a Newton solver this method should return the Jacobian, while for a steepest descent method this can be a preconditioner as e.g., the L2 product of the gradients. By default the system matrix for the SteepestDescent method is the unity matrix and thus, renders a vanilla gradient descent solver.\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#Additional-functions","page":"User problem","title":"Additional functions","text":"","category":"section"},{"location":"userfunctions/","page":"User problem","title":"User problem","text":"These functions are usually not necessary to overload ","category":"page"},{"location":"userfunctions/","page":"User problem","title":"User problem","text":"FESolvers.setunknowns!","category":"page"},{"location":"userfunctions/#FESolvers.setunknowns!","page":"User problem","title":"FESolvers.setunknowns!","text":"setunknowns!(problem, x)\n\nCopy the given values x into the unknown values of problem.  Defaults to copy!(getunknowns(problem), x), which works as long as getunknowns returns the Vector{<:Number} stored in the problem struct.  If, e.g. the unknowns is a custom type or a nested vector, this function should  be overloaded. \n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FESolvers","category":"page"},{"location":"#FESolvers","page":"Home","title":"FESolvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FESolvers.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"solve_problem!\nQuasiStaticSolver","category":"page"},{"location":"#FESolvers.solve_problem!","page":"Home","title":"FESolvers.solve_problem!","text":"solve_problem!(problem, solver)\n\nSolve a given user problem using the chosen solver\n\nFor details on the functions that should be defined for problem, see User problem\n\n\n\n\n\n","category":"function"},{"location":"#FESolvers.QuasiStaticSolver","page":"Home","title":"FESolvers.QuasiStaticSolver","text":"QuasiStaticSolver(nlsolver, timestepper)\n\nA quasi-static solver that solves problems of the type R(X(t),t)=0.  It has two parts: A nonlinear solver (see Nonlinear solvers)  and a time stepper (see Time steppers). \n\n\n\n\n\n","category":"type"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"EditURL = \"../literate/transient_heat.jl\"","category":"page"},{"location":"examples/transient_heat/#Linear-Time-Dependent-Problem","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"This example is taken from Ferrite.jl's transient heat flow. We modify the material parameters to get more time-dependent behavior.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Currently, only Quasi-static problems are supported by FESolvers. Therefore, we reformulate the linear system compared to remove the mass matrices. We have the same time-discretized weak form:","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"int_Omega v u_n+1 mathrmdOmega + Delta tint_Omega k nabla v cdot nabla u_n+1  mathrmdOmega = Delta tint_Omega v f  mathrmdOmega + int_Omega v  u_n  mathrmdOmega","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We then define the linear residual, r(u_n+1), as","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"r(u_n+1) = f_mathrmint(u_n+1) - f_mathrmext(u_n) \nf_mathrmint(u_n+1) = int_Omega v u_n+1 mathrmdOmega + Delta tint_Omega k nabla v cdot nabla u_n+1  mathrmdOmega  \nf_mathrmext(u_n) = Delta tint_Omega v f  mathrmdOmega + int_Omega v  u_n  mathrmdOmega ","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"giving the discrete operators","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"r_i(mathbfu_n+1) = K_ij mathbfu_n+1_j - mathbff_mathrmext(u_n)_i","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"upon introduction of the function approximation, u(mathbfx) approx N_i(mathbfx) u_i, and the test approximation, v(mathbfx) approx delta N_i(mathbfx) v_i where","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"K_ij = int_Omega delta N_i(mathbfx) N_j(mathbfx)  mathrmdOmega + Delta tint_Omega k nabla delta N_i(mathbfx) cdot nabla N_j(mathbfx)  mathrmdOmega  \nleftmathbff_mathrmext(u_n)right_i = Delta tint_Omega delta N_i(mathbfx) f  mathrmdOmega + int_Omega delta N_i(mathbfx)  u_n(mathbfx)  mathrmdOmega","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"and the residual expression can be simplified to","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"r_i =\nint_Omega delta N_i(mathbfx) leftu(mathbfx)-u_n(mathbfx)right  mathrmdOmega\n+ Delta tint_Omega k nabla delta N_i(mathbfx) cdot nabla u(mathbfx)  mathrmdOmega\n- Delta tint_Omega delta N_i(mathbfx) f  mathrmdOmega","category":"page"},{"location":"examples/transient_heat/#Commented-Program","page":"Linear Time Dependent Problem","title":"Commented Program","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Now we solve the problem by using Ferrite and FESolvers. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"First we load Ferrite, and some other packages we need.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"using Ferrite, SparseArrays, FESolvers","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Then, we define our problem structs. At the end, we will define a nice constructor for this.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"struct TransientHeat{DEF,BUF,POST}\n    def::DEF    # Problem definition\n    buf::BUF    # Buffers for storing values\n    post::POST  # Struct to save simulation data in each step\nend\n\nstruct ProblemDefinition{DH,CH,CV}\n    dh::DH\n    ch::CH\n    cv::CV\nend\n\nfunction ProblemDefinition()\n    # **Grid**\n    grid = generate_grid(Quadrilateral, (100, 100));\n\n    # **Cell values**\n    dim = 2\n    ip = Lagrange{dim, RefCube, 1}()\n    qr = QuadratureRule{dim, RefCube}(2)\n    cellvalues = CellScalarValues(qr, ip);\n\n    # **Degrees of freedom**\n    # After this, we can define the `DofHandler` and distribute the DOFs of the problem.\n    dh = DofHandler(grid)\n    push!(dh, :u, 1)\n    close!(dh);\n\n    # **Boundary conditions**\n    # In order to define the time dependent problem, we need some end time `T` and something that describes\n    # the linearly increasing Dirichlet boundary condition on $\\partial \\Omega_2$.\n    max_temp = 100\n    t_rise = 100\n    ch = ConstraintHandler(dh);\n\n    # Here, we define the boundary condition related to $\\partial \\Omega_1$.\n    ∂Ω₁ = union(getfaceset.((grid,), [\"left\", \"right\"])...)\n    dbc = Dirichlet(:u, ∂Ω₁, (x, t) -> 0)\n    add!(ch, dbc);\n    # While the next code block corresponds to the linearly increasing temperature description on $\\partial \\Omega_2$\n    # until `t=t_rise`, and then keep constant\n    ∂Ω₂ = union(getfaceset.((grid,), [\"top\", \"bottom\"])...)\n    dbc = Dirichlet(:u, ∂Ω₂, (x, t) -> max_temp * clamp(t / t_rise, 0, 1))\n    add!(ch, dbc)\n    close!(ch)\n    return ProblemDefinition(dh, ch, cellvalues)\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We then define a problem buffer, that can be created based on the ProblemDefinition","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"struct ProblemBuffer{KT,T}\n    K::KT\n    r::Vector{T}\n    u::Vector{T}\n    uold::Vector{T}\n    times::Vector{T}    # [t_old, t_current]\nend\nfunction ProblemBuffer(def::ProblemDefinition)\n    dh = def.dh\n    K = create_sparsity_pattern(dh)\n    r = zeros(ndofs(dh))\n    u = zeros(ndofs(dh))\n    uold = zeros(ndofs(dh))\n    times = zeros(2)\n    return ProblemBuffer(K, r, u, uold, times)\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We also need functions to assemble the stiffness and residual vectors","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function doassemble!(K::SparseMatrixCSC, r::Vector, cellvalues::CellScalarValues, dh::DofHandler, u, uold, Δt)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    re = zeros(n_basefuncs)\n    ue = zeros(n_basefuncs)\n    ue_old = zeros(n_basefuncs)\n    assembler = start_assemble(K, r)\n    for cell in CellIterator(dh)\n        fill!(Ke, 0)\n        fill!(re, 0)\n        ue .= u[celldofs(cell)]\n        ue_old .= uold[celldofs(cell)]\n        reinit!(cellvalues, cell)\n        element_routine!(Ke, re, cellvalues, ue, ue_old, Δt)\n        assemble!(assembler, celldofs(cell), re, Ke)\n    end\nend\n\nfunction element_routine!(Ke, re, cellvalues, ue, ue_old, Δt, k=1.0e-3, f=0.5)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        u = function_value(cellvalues, q_point, ue)\n        uold = function_value(cellvalues, q_point, ue_old)\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        for i in 1:n_basefuncs\n            δN = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            re[i] += (δN * (u - uold - Δt * f) + Δt * k * ∇δN ⋅ ∇u) * dΩ\n            for j in 1:n_basefuncs\n                N = shape_value(cellvalues, q_point, j)\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                Ke[i, j] += (δN*N + Δt * k * (∇δN ⋅ ∇N)) * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We now define all the required methods for solving this system with using the LinearProblemSolver","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"FESolvers.getunknowns(p::TransientHeat) = p.buf.u\nFESolvers.getresidual(p::TransientHeat) = p.buf.r\nFESolvers.getjacobian(p::TransientHeat) = p.buf.K\n\nfunction FESolvers.update_to_next_step!(p::TransientHeat, time)\n    p.buf.times[2] = time       # Update current time\n    update!(p.def.ch, time)     # Update Dirichlet boundary conditions\n    apply!(FESolvers.getunknowns(p), p.def.ch)\nend\n\nfunction FESolvers.update_problem!(p::TransientHeat, Δu, update_spec)\n    if !isnothing(Δu)\n        apply_zero!(Δu, p.def.ch)\n        p.buf.u .+= Δu\n    end\n    # Since the problem is linear, we can save some computations by only updating once per time step\n    # and not after updating the temperatures to check that it has converged.\n    if FESolvers.should_update_jacobian(update_spec) || FESolvers.should_update_residual(update_spec)\n        Δt = p.buf.times[2]-p.buf.times[1]\n        doassemble!(p.buf.K, p.buf.r, p.def.cv, p.def.dh, FESolvers.getunknowns(p), p.buf.uold, Δt)\n        apply_zero!(FESolvers.getjacobian(p), FESolvers.getresidual(p), p.def.ch)\n    end\n    return nothing\nend\n\nfunction FESolvers.handle_converged!(p::TransientHeat)\n    copy!(p.buf.uold, FESolvers.getunknowns(p)) # Set old temperature to current\n    p.buf.times[1] = p.buf.times[2]             # Set old time to current\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We are now ready to solve the system, but to save some data we must define some postprocessing tasks In this example, we only save things to file","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"struct PostProcessing{PVD}\n    pvd::PVD\nend\nPostProcessing() = PostProcessing(paraview_collection(\"transient-heat.pvd\"));\n\nfunction FESolvers.postprocess!(p::TransientHeat, solver)\n    step = FESolvers.get_step(solver)\n    vtk_grid(\"transient-heat-$step\", p.def.dh) do vtk\n        vtk_point_data(vtk, p.def.dh, p.buf.u)\n        vtk_save(vtk)\n        p.post.pvd[step] = vtk\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"At the end of the simulation, we want to finish all IO operations. We can then define the function close_problem which will be called even in the case that an error is thrown during the simulation","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FESolvers.close_problem(p::TransientHeat)\n    vtk_save(p.post.pvd)\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We then define a nice constructor for TransientHeat and can solve the problem,","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"TransientHeat(def) = TransientHeat(def, ProblemBuffer(def), PostProcessing());\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"And now we create the problem type, and define the QuasiStaticSolver with the LinearProblemSolver as well as fixed time steps","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"problem = TransientHeat(ProblemDefinition())\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(collect(0.0:1.0:200)));\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Finally, we can solve the problem","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"solve_problem!(problem, solver);\nnothing #hide","category":"page"},{"location":"examples/transient_heat/#transient_heat-plain-program","page":"Linear Time Dependent Problem","title":"Plain program","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Here follows a version of the program without any comments. The file is also available here: transient_heat.jl.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"using Ferrite, SparseArrays, FESolvers\n\nstruct TransientHeat{DEF,BUF,POST}\n    def::DEF    # Problem definition\n    buf::BUF    # Buffers for storing values\n    post::POST  # Struct to save simulation data in each step\nend\n\nstruct ProblemDefinition{DH,CH,CV}\n    dh::DH\n    ch::CH\n    cv::CV\nend\n\nfunction ProblemDefinition()\n    # **Grid**\n    grid = generate_grid(Quadrilateral, (100, 100));\n\n    # **Cell values**\n    dim = 2\n    ip = Lagrange{dim, RefCube, 1}()\n    qr = QuadratureRule{dim, RefCube}(2)\n    cellvalues = CellScalarValues(qr, ip);\n\n    # **Degrees of freedom**\n    # After this, we can define the `DofHandler` and distribute the DOFs of the problem.\n    dh = DofHandler(grid)\n    push!(dh, :u, 1)\n    close!(dh);\n\n    # **Boundary conditions**\n    # In order to define the time dependent problem, we need some end time `T` and something that describes\n    # the linearly increasing Dirichlet boundary condition on $\\partial \\Omega_2$.\n    max_temp = 100\n    t_rise = 100\n    ch = ConstraintHandler(dh);\n\n    # Here, we define the boundary condition related to $\\partial \\Omega_1$.\n    ∂Ω₁ = union(getfaceset.((grid,), [\"left\", \"right\"])...)\n    dbc = Dirichlet(:u, ∂Ω₁, (x, t) -> 0)\n    add!(ch, dbc);\n    # While the next code block corresponds to the linearly increasing temperature description on $\\partial \\Omega_2$\n    # until `t=t_rise`, and then keep constant\n    ∂Ω₂ = union(getfaceset.((grid,), [\"top\", \"bottom\"])...)\n    dbc = Dirichlet(:u, ∂Ω₂, (x, t) -> max_temp * clamp(t / t_rise, 0, 1))\n    add!(ch, dbc)\n    close!(ch)\n    return ProblemDefinition(dh, ch, cellvalues)\nend;\n\nstruct ProblemBuffer{KT,T}\n    K::KT\n    r::Vector{T}\n    u::Vector{T}\n    uold::Vector{T}\n    times::Vector{T}    # [t_old, t_current]\nend\nfunction ProblemBuffer(def::ProblemDefinition)\n    dh = def.dh\n    K = create_sparsity_pattern(dh)\n    r = zeros(ndofs(dh))\n    u = zeros(ndofs(dh))\n    uold = zeros(ndofs(dh))\n    times = zeros(2)\n    return ProblemBuffer(K, r, u, uold, times)\nend;\n\nfunction doassemble!(K::SparseMatrixCSC, r::Vector, cellvalues::CellScalarValues, dh::DofHandler, u, uold, Δt)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    re = zeros(n_basefuncs)\n    ue = zeros(n_basefuncs)\n    ue_old = zeros(n_basefuncs)\n    assembler = start_assemble(K, r)\n    for cell in CellIterator(dh)\n        fill!(Ke, 0)\n        fill!(re, 0)\n        ue .= u[celldofs(cell)]\n        ue_old .= uold[celldofs(cell)]\n        reinit!(cellvalues, cell)\n        element_routine!(Ke, re, cellvalues, ue, ue_old, Δt)\n        assemble!(assembler, celldofs(cell), re, Ke)\n    end\nend\n\nfunction element_routine!(Ke, re, cellvalues, ue, ue_old, Δt, k=1.0e-3, f=0.5)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        u = function_value(cellvalues, q_point, ue)\n        uold = function_value(cellvalues, q_point, ue_old)\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        for i in 1:n_basefuncs\n            δN = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            re[i] += (δN * (u - uold - Δt * f) + Δt * k * ∇δN ⋅ ∇u) * dΩ\n            for j in 1:n_basefuncs\n                N = shape_value(cellvalues, q_point, j)\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                Ke[i, j] += (δN*N + Δt * k * (∇δN ⋅ ∇N)) * dΩ\n            end\n        end\n    end\nend;\n\nFESolvers.getunknowns(p::TransientHeat) = p.buf.u\nFESolvers.getresidual(p::TransientHeat) = p.buf.r\nFESolvers.getjacobian(p::TransientHeat) = p.buf.K\n\nfunction FESolvers.update_to_next_step!(p::TransientHeat, time)\n    p.buf.times[2] = time       # Update current time\n    update!(p.def.ch, time)     # Update Dirichlet boundary conditions\n    apply!(FESolvers.getunknowns(p), p.def.ch)\nend\n\nfunction FESolvers.update_problem!(p::TransientHeat, Δu, update_spec)\n    if !isnothing(Δu)\n        apply_zero!(Δu, p.def.ch)\n        p.buf.u .+= Δu\n    end\n    # Since the problem is linear, we can save some computations by only updating once per time step\n    # and not after updating the temperatures to check that it has converged.\n    if FESolvers.should_update_jacobian(update_spec) || FESolvers.should_update_residual(update_spec)\n        Δt = p.buf.times[2]-p.buf.times[1]\n        doassemble!(p.buf.K, p.buf.r, p.def.cv, p.def.dh, FESolvers.getunknowns(p), p.buf.uold, Δt)\n        apply_zero!(FESolvers.getjacobian(p), FESolvers.getresidual(p), p.def.ch)\n    end\n    return nothing\nend\n\nfunction FESolvers.handle_converged!(p::TransientHeat)\n    copy!(p.buf.uold, FESolvers.getunknowns(p)) # Set old temperature to current\n    p.buf.times[1] = p.buf.times[2]             # Set old time to current\nend;\n\nstruct PostProcessing{PVD}\n    pvd::PVD\nend\nPostProcessing() = PostProcessing(paraview_collection(\"transient-heat.pvd\"));\n\nfunction FESolvers.postprocess!(p::TransientHeat, solver)\n    step = FESolvers.get_step(solver)\n    vtk_grid(\"transient-heat-$step\", p.def.dh) do vtk\n        vtk_point_data(vtk, p.def.dh, p.buf.u)\n        vtk_save(vtk)\n        p.post.pvd[step] = vtk\n    end\nend;\n\nfunction FESolvers.close_problem(p::TransientHeat)\n    vtk_save(p.post.pvd)\nend;\n\nTransientHeat(def) = TransientHeat(def, ProblemBuffer(def), PostProcessing());\n\nproblem = TransientHeat(ProblemDefinition())\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(collect(0.0:1.0:200)));\n\nsolve_problem!(problem, solver);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"timesteppers/#Time-steppers","page":"Time steppers","title":"Time steppers","text":"","category":"section"},{"location":"timesteppers/","page":"Time steppers","title":"Time steppers","text":"The following time steppers are implemented in FESolvers.","category":"page"},{"location":"timesteppers/","page":"Time steppers","title":"Time steppers","text":"FixedTimeStepper\nAdaptiveTimeStepper","category":"page"},{"location":"timesteppers/#FESolvers.FixedTimeStepper","page":"Time steppers","title":"FESolvers.FixedTimeStepper","text":"FixedTimeStepper(;num_steps::Int, Δt=1, t_start=0)\nFixedTimeStepper(t::Vector)\n\nA time stepper which gives fixed time steps. If the convenience interface is used, constant increments are used. Note that  length(t)=num_steps+1 since the first value is just the initial  value and is not an actual step.  \n\n\n\n\n\n","category":"type"},{"location":"timesteppers/#FESolvers.AdaptiveTimeStepper","page":"Time steppers","title":"FESolvers.AdaptiveTimeStepper","text":"AdaptiveTimeStepper(\n    Δt_init::T, t_end::T; \n    t_start=zero(T), Δt_min=Δt_init, Δt_max=typemax(T), \n    change_factor=T(0.5), optiter_ratio=T(0.5), k=one(T)) where T\n\nAn adaptive time stepper with an initial step Δt_init and total   time t_end. Two ways of adaption:\n\nIf the previous attempt did not converge, the time \n\nstep is reduced as Δt*=change_factor and the step is retried. \n\nIf convergence, the next time step depends on how many iterations was \n\nrequired to converge; numiter. The time step is changed as  Δt*=change_factor^(k*m), where m=(numiter-optiter)/(maxiter-optiter). In this expression, maxiter and optiter are the maximum and optimum  number of iterations for the nonlinear solver.  optiter=floor(maxiter*optiter_ratio) and maxiter is obtained from  the nonlinear solver (via get_max_iter(s))\n\nIf numiter=maxiter, then m=1 and the time step update is the same as for a non-converged solution if k=1. Note that k>0, change_factor∈[0,1], and optiter_ratio∈[0,1] are expected, otherwise warnings are thrown. \n\n\n\n\n\n","category":"type"},{"location":"timesteppers/#Custom-time-stepper","page":"Time steppers","title":"Custom time stepper","text":"","category":"section"},{"location":"timesteppers/","page":"Time steppers","title":"Time steppers","text":"A time stepper should support the following functions","category":"page"},{"location":"timesteppers/","page":"Time steppers","title":"Time steppers","text":"FESolvers.get_time\nFESolvers.get_step\nFESolvers.is_last_step\nFESolvers.step_time!\nFESolvers.reset_timestepper!","category":"page"},{"location":"timesteppers/#FESolvers.get_time","page":"Time steppers","title":"FESolvers.get_time","text":"get_time(timestepper)\n\nReturn the current time for timestepper\n\n\n\n\n\n","category":"function"},{"location":"timesteppers/#FESolvers.get_step","page":"Time steppers","title":"FESolvers.get_step","text":"get_step(timestepper)\n\nReturn the current step number\n\n\n\n\n\n","category":"function"},{"location":"timesteppers/#FESolvers.is_last_step","page":"Time steppers","title":"FESolvers.is_last_step","text":"is_last_step(timestepper)->Bool\n\nReturn true if the current step/time is the last step, return false otherwise \n\n\n\n\n\n","category":"function"},{"location":"timesteppers/#FESolvers.step_time!","page":"Time steppers","title":"FESolvers.step_time!","text":"step_time!(solver)\nstep_time!(timestepper, nlsolver)\n\nIncrement the timestepper depending on the convergence status of nlsolver. If not converged and a smaller time step is not possible, throw ConvergenceError. \n\nNote that a call to the first definition is forwarded to the second function definition  by decomposing the solver, unless another specialization is defined.\n\n\n\n\n\n","category":"function"},{"location":"timesteppers/#FESolvers.reset_timestepper!","page":"Time steppers","title":"FESolvers.reset_timestepper!","text":"reset_timestepper!(timestepper)\n\nReset the time and step in timestepper\n\n\n\n\n\n","category":"function"}]
}
