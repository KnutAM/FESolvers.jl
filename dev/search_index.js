var documenterSearchIndex = {"docs":
[{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"EditURL = \"https://github.com/KnutAM/FESolvers.jl/blob/main/docs/src/literate/plasticity.jl\"","category":"page"},{"location":"examples/plasticity/#Plasticity","page":"Plasticity","title":"Plasticity","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This example is taken from Ferrite.jl's plasticity example and shows how FESolvers can be used to solve this nonlinear problem with time dependent loading.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"note: Note\nThis example is preliminary, and does not represent good coding practice. This will be improved in the future as the FESolvers package matures","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First we need to load all required packages","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using FESolvers, Ferrite, Tensors, SparseArrays, LinearAlgebra, Plots","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We first include some basic definitions taken and modified from the original example. These definitions are available here: plasticity_definitions.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"include(\"plasticity_definitions.jl\");\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Problem-definition","page":"Plasticity","title":"Problem definition","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We divide the problem struct into three parts: definitions (def), a buffer (buf), and postprocessing (post) to structure the information and make it easier to save the simulation settings (enough to save def as the others will be created based on this one)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityProblem{PD,PB,PP}\n    def::PD\n    buf::PB\n    post::PP\nend","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"PlasticityModel is our def and contain all problem settings (mesh, material, loads, interpolations, etc.)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityModel\n    grid\n    interpolation\n    dh\n    material\n    traction_rate\n    dbcs\nend\n\nfunction PlasticityModel()\n    E = 200.0e9\n    H = E/20\n    ν = 0.3\n    σ₀ = 200e6\n    material = J2Plasticity(E, ν, σ₀, H)\n\n    L = 10.0\n    w = 1.0\n    h = 1.0\n\n    traction_rate = 1.e7    # N/s\n\n    n = 2\n    nels = (10n, n, 2n)\n    P1 = Vec((0.0, 0.0, 0.0))\n    P2 = Vec((L, w, h))\n    grid = generate_grid(Tetrahedron, nels, P1, P2)\n    interpolation = Lagrange{3, RefTetrahedron, 1}()\n    dh = create_dofhandler(grid, interpolation)\n    dbcs = create_bc(dh, grid)\n    return PlasticityModel(grid,interpolation,dh,material,traction_rate,dbcs)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"PlasticityFEBuffer is our buf and contain all problem arrays and other allocated values","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityFEBuffer\n    cellvalues\n    facevalues\n    K\n    r\n    u\n    states\n    states_old\n    time::Vector # length(time)=1, could use ScalarBuffer instead\nend\n\nfunction build_febuffer(model::PlasticityModel)\n    dh = model.dh\n    n_dofs = ndofs(dh)\n    cellvalues, facevalues = create_values(model.interpolation)\n    u  = zeros(n_dofs)\n    r = zeros(n_dofs)\n    K = create_sparsity_pattern(dh)\n    nqp = getnquadpoints(cellvalues)\n    states = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.grid)]\n    states_old = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.grid)]\n    return PlasticityFEBuffer(cellvalues,facevalues,K,r,u,states,states_old,[0.0])\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, we define our post that contains variables that we will save during the simulation","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"struct PlasticityPost{T}\n    umax::Vector{T}\n    tmag::Vector{T}\nend\nPlasticityPost() = PlasticityPost(Float64[],Float64[]);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"To facilitate reuse, we define a function that gives our full problem struct based on the problem definition","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"build_problem(def::PlasticityModel) = PlasticityProblem(def, build_febuffer(def), PlasticityPost());\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Neumann-boundary-conditions","page":"Plasticity","title":"Neumann boundary conditions","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We then define a separate function for the Neumann boundary conditions (note that this difference to the original example is not required, but only to separate the element assembly and external boundary conditions)","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function apply_neumann!(model::PlasticityModel,buffer::PlasticityFEBuffer)\n    t = buffer.time[1]\n    nu = getnbasefunctions(buffer.cellvalues)\n    re = zeros(nu)\n    facevalues = buffer.facevalues\n    grid = model.grid\n    traction = Vec((0.0, 0.0, model.traction_rate*t))\n\n    for (i, cell) in enumerate(CellIterator(model.dh))\n        fill!(re, 0)\n        eldofs = celldofs(cell)\n        for face in 1:nfaces(cell)\n            if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"right\")\n                reinit!(facevalues, cell, face)\n                for q_point in 1:getnquadpoints(facevalues)\n                    dΓ = getdetJdV(facevalues, q_point)\n                    for i in 1:nu\n                        δu = shape_value(facevalues, q_point, i)\n                        re[i] -= (δu ⋅ traction) * dΓ\n                    end\n                end\n            end\n        end\n        buffer.r[eldofs] .+= re\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Specialized-functions-for-our-problem","page":"Plasticity","title":"Specialized functions for our problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We first define our \"get\"-functions to get the key arrays for our problem. Note that these functions don't calculate or update anything, that updating is taken care of by update-update_to_next_step! and update_problem! below.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"FESolvers.getunknowns(p::PlasticityProblem) = p.buf.u;\nFESolvers.getresidual(p::PlasticityProblem) = p.buf.r;\nFESolvers.getjacobian(p::PlasticityProblem) = p.buf.K;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"We then define the function to update the problem to a different time. This is typically used to set time dependent boundary conditions. Here, it is also possible to make an improved guess for the solution to this time step if desired.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.update_to_next_step!(p::PlasticityProblem, time)\n    p.buf.time .= time\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Next, we define the updating of the problem given a new guess to the solution. Note that we use Δu::Nothing for the case it is not given, to signal no change. This version is called directly after updatetonext_step! before entering the nonlinear iterations.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.update_problem!(p::PlasticityProblem, Δu; kwargs...)\n    buf = p.buf\n    def = p.def\n    if !isnothing(Δu)\n        apply_zero!(Δu, p.def.dbcs)\n        buf.u .+= Δu\n    end\n    doassemble!(buf.cellvalues, buf.facevalues, buf.K, buf.r,\n                def.grid, def.dh, def.material, buf.u, buf.states, buf.states_old)\n    apply_neumann!(def,buf)\n    apply_zero!(buf.K, buf.r, def.dbcs)\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"In this example, we use the standard convergence criterion that the norm of the free degrees of freedom is less than the iteration tolerance.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"FESolvers.calculate_convergence_measure(p::PlasticityProblem, args...) = norm(FESolvers.getresidual(p)[free_dofs(p.def.dbcs)]);\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"After convergence, we need to update the state variables.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.handle_converged!(p::PlasticityProblem)\n    p.buf.states_old .= p.buf.states\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"As postprocessing, which is called after handle_converged!, we save the maximum displacement as well as the traction magnitude.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function FESolvers.postprocess!(p::PlasticityProblem, step)\n    push!(p.post.umax, maximum(abs, FESolvers.getunknowns(p)))\n    push!(p.post.tmag, p.def.traction_rate*p.buf.time[1])\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/#Solving-the-problem","page":"Plasticity","title":"Solving the problem","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"First, we define a helper function to plot the results after the solution","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function plot_results(problem::PlasticityProblem; plt=plot(), label=nothing, markershape=:auto, markersize=4)\n    umax = vcat(0.0, problem.post.umax)\n    tmag = vcat(0.0, problem.post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\nnothing #hide","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Finally, we can solve the problem with different time stepping strategies and plot the results","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"function example_solution()\n    def = PlasticityModel()\n\n    # Fixed uniform time steps\n    problem = build_problem(def)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    solve_problem!(problem, solver)\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example\n    problem = build_problem(def)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    solve_problem!(problem, solver)\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping\n    problem = build_problem(def)\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    solve_problem!(problem, solver)\n    println(problem.buf.time)\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n    plot!(;legend=:bottomright)\nend;\n\nexample_solution()","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Which gives the following result (Image: )","category":"page"},{"location":"examples/plasticity/#Plain-program","page":"Plasticity","title":"Plain program","text":"","category":"section"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"Here follows a version of the program without any comments. The file is also available here: plasticity.jl.","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"using FESolvers, Ferrite, Tensors, SparseArrays, LinearAlgebra, Plots\n\ninclude(\"plasticity_definitions.jl\");\n\nstruct PlasticityProblem{PD,PB,PP}\n    def::PD\n    buf::PB\n    post::PP\nend\n\nstruct PlasticityModel\n    grid\n    interpolation\n    dh\n    material\n    traction_rate\n    dbcs\nend\n\nfunction PlasticityModel()\n    E = 200.0e9\n    H = E/20\n    ν = 0.3\n    σ₀ = 200e6\n    material = J2Plasticity(E, ν, σ₀, H)\n\n    L = 10.0\n    w = 1.0\n    h = 1.0\n\n    traction_rate = 1.e7    # N/s\n\n    n = 2\n    nels = (10n, n, 2n)\n    P1 = Vec((0.0, 0.0, 0.0))\n    P2 = Vec((L, w, h))\n    grid = generate_grid(Tetrahedron, nels, P1, P2)\n    interpolation = Lagrange{3, RefTetrahedron, 1}()\n    dh = create_dofhandler(grid, interpolation)\n    dbcs = create_bc(dh, grid)\n    return PlasticityModel(grid,interpolation,dh,material,traction_rate,dbcs)\nend;\n\nstruct PlasticityFEBuffer\n    cellvalues\n    facevalues\n    K\n    r\n    u\n    states\n    states_old\n    time::Vector # length(time)=1, could use ScalarBuffer instead\nend\n\nfunction build_febuffer(model::PlasticityModel)\n    dh = model.dh\n    n_dofs = ndofs(dh)\n    cellvalues, facevalues = create_values(model.interpolation)\n    u  = zeros(n_dofs)\n    r = zeros(n_dofs)\n    K = create_sparsity_pattern(dh)\n    nqp = getnquadpoints(cellvalues)\n    states = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.grid)]\n    states_old = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.grid)]\n    return PlasticityFEBuffer(cellvalues,facevalues,K,r,u,states,states_old,[0.0])\nend;\n\nstruct PlasticityPost{T}\n    umax::Vector{T}\n    tmag::Vector{T}\nend\nPlasticityPost() = PlasticityPost(Float64[],Float64[]);\n\nbuild_problem(def::PlasticityModel) = PlasticityProblem(def, build_febuffer(def), PlasticityPost());\n\nfunction apply_neumann!(model::PlasticityModel,buffer::PlasticityFEBuffer)\n    t = buffer.time[1]\n    nu = getnbasefunctions(buffer.cellvalues)\n    re = zeros(nu)\n    facevalues = buffer.facevalues\n    grid = model.grid\n    traction = Vec((0.0, 0.0, model.traction_rate*t))\n\n    for (i, cell) in enumerate(CellIterator(model.dh))\n        fill!(re, 0)\n        eldofs = celldofs(cell)\n        for face in 1:nfaces(cell)\n            if onboundary(cell, face) && (cellid(cell), face) ∈ getfaceset(grid, \"right\")\n                reinit!(facevalues, cell, face)\n                for q_point in 1:getnquadpoints(facevalues)\n                    dΓ = getdetJdV(facevalues, q_point)\n                    for i in 1:nu\n                        δu = shape_value(facevalues, q_point, i)\n                        re[i] -= (δu ⋅ traction) * dΓ\n                    end\n                end\n            end\n        end\n        buffer.r[eldofs] .+= re\n    end\nend;\n\nFESolvers.getunknowns(p::PlasticityProblem) = p.buf.u;\nFESolvers.getresidual(p::PlasticityProblem) = p.buf.r;\nFESolvers.getjacobian(p::PlasticityProblem) = p.buf.K;\n\nfunction FESolvers.update_to_next_step!(p::PlasticityProblem, time)\n    p.buf.time .= time\nend;\n\nfunction FESolvers.update_problem!(p::PlasticityProblem, Δu; kwargs...)\n    buf = p.buf\n    def = p.def\n    if !isnothing(Δu)\n        apply_zero!(Δu, p.def.dbcs)\n        buf.u .+= Δu\n    end\n    doassemble!(buf.cellvalues, buf.facevalues, buf.K, buf.r,\n                def.grid, def.dh, def.material, buf.u, buf.states, buf.states_old)\n    apply_neumann!(def,buf)\n    apply_zero!(buf.K, buf.r, def.dbcs)\nend;\n\nFESolvers.calculate_convergence_measure(p::PlasticityProblem, args...) = norm(FESolvers.getresidual(p)[free_dofs(p.def.dbcs)]);\n\nfunction FESolvers.handle_converged!(p::PlasticityProblem)\n    p.buf.states_old .= p.buf.states\nend;\n\nfunction FESolvers.postprocess!(p::PlasticityProblem, step)\n    push!(p.post.umax, maximum(abs, FESolvers.getunknowns(p)))\n    push!(p.post.tmag, p.def.traction_rate*p.buf.time[1])\nend;\n\nfunction plot_results(problem::PlasticityProblem; plt=plot(), label=nothing, markershape=:auto, markersize=4)\n    umax = vcat(0.0, problem.post.umax)\n    tmag = vcat(0.0, problem.post.tmag)\n    plot!(plt, umax, tmag, linewidth=0.5, title=\"Traction-displacement\", label=label,\n        markeralpha=0.75, markershape=markershape, markersize=markersize)\n    ylabel!(plt, \"Traction [Pa]\")\n    xlabel!(plt, \"Maximum deflection [m]\")\n    return plt\nend;\n\nfunction example_solution()\n    def = PlasticityModel()\n\n    # Fixed uniform time steps\n    problem = build_problem(def)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(;num_steps=25,Δt=0.04))\n    solve_problem!(problem, solver)\n    plt = plot_results(problem, label=\"uniform\", markershape=:x, markersize=5)\n\n    # Same time steps as Ferrite example\n    problem = build_problem(def)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))\n    solve_problem!(problem, solver)\n    plot_results(problem, plt=plt, label=\"fixed\", markershape=:circle)\n\n    # Adaptive time stepping\n    problem = build_problem(def)\n    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)\n    solver = QuasiStaticSolver(NewtonSolver(;tolerance=1.0, maxiter=6), ts)\n    solve_problem!(problem, solver)\n    println(problem.buf.time)\n    plot_results(problem, plt=plt, label=\"adaptive\", markershape=:circle)\n    plot!(;legend=:bottomright)\nend;\n\nexample_solution()\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"","category":"page"},{"location":"examples/plasticity/","page":"Plasticity","title":"Plasticity","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"Solvers are the top level object in this package,  each solver should define the function ","category":"page"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"FESolvers.solve_problem!","category":"page"},{"location":"solvers/#Implemented-Solvers","page":"Solvers","title":"Implemented Solvers","text":"","category":"section"},{"location":"solvers/","page":"Solvers","title":"Solvers","text":"QuasiStaticSolver","category":"page"},{"location":"nlsolvers/#Nonlinear-solvers","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"A nonlinear solver should support the solve_nonlinear! function specified below. ","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.solve_nonlinear!","category":"page"},{"location":"nlsolvers/#FESolvers.solve_nonlinear!","page":"Nonlinear solvers","title":"FESolvers.solve_nonlinear!","text":"solve_nonlinear!(problem, nlsolver)\n\nSolve the current time step in the nonlinear problem, (r(x) = 0), by using the nonlinear solver: nlsolver. \n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"It can do so, by supporting the following functions","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.calculate_update!\nFESolvers.getmaxiter\nFESolvers.gettolerance","category":"page"},{"location":"nlsolvers/#FESolvers.calculate_update!","page":"Nonlinear solvers","title":"FESolvers.calculate_update!","text":"function calculate_update!(Δx, problem, nlsolver, iter)\n\nAccording to the nonlinear solver, nlsolver, at iteration iter, calculate the update, Δx to the unknowns x.\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.getmaxiter","page":"Nonlinear solvers","title":"FESolvers.getmaxiter","text":"getmaxiter(nlsolver)\n\nReturns the maximum number of iterations allowed for the nonlinear solver\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.gettolerance","page":"Nonlinear solvers","title":"FESolvers.gettolerance","text":"gettolerance(nlsolver)\n\nReturns the iteration tolerance for the solver\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"and optionally","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"FESolvers.update_state!\nFESolvers.reset_state!","category":"page"},{"location":"nlsolvers/#FESolvers.update_state!","page":"Nonlinear solvers","title":"FESolvers.update_state!","text":"update_state!(nlsolver, r)\n\nA nonlinear solver may solve information about its convergence state. r is the output from calculate_convergence_measure when  this function is called by the default implementation of  check_convergence_criteria.  update_state! is optional to implement\n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#FESolvers.reset_state!","page":"Nonlinear solvers","title":"FESolvers.reset_state!","text":"reset_state!(nlsolver)\n\nIf update_state! is implemented, this function is used to  reset its state at the beginning of each new time step. \n\n\n\n\n\n","category":"function"},{"location":"nlsolvers/#Implemented-Solvers","page":"Nonlinear solvers","title":"Implemented Solvers","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"LinearProblemSolver\nNewtonSolver\nSteepestDescent","category":"page"},{"location":"nlsolvers/#FESolvers.LinearProblemSolver","page":"Nonlinear solvers","title":"FESolvers.LinearProblemSolver","text":"LinearProblemSolver(;linsolver=BackslashSolver())\n\nThis is a special type of \"Nonlinear solver\", which actually only solves linear problems,  but allows all other features (i.e. time stepping and postprocessing) of the FESolvers  package to be used. In particular, it allows you to maintain all other parts of your problem  exactly the same as for a nonlinear problem, but it is possible to get better performance as  it is, in principle, not necessary to assemble twice in each time step. \n\nThis solver is specialized for linear problems of the form\n\nboldsymbolr(boldsymbolx(t)t)=boldsymbolK(t) boldsymbolx(t) - boldsymbolf(t)\n\nwhere boldsymbolK=partial boldsymbolrpartial boldsymbolx.  It expects that boldsymbolx(t) and boldsymbolr(t) have been updated to  boldsymbolx_mathrmbc and boldsymbolr_mathrmbc=boldsymbolK(t)boldsymbolx_mathrmbc-boldsymbolf(t), such that \n\nboldsymbolx(t) = boldsymbolx_mathrmbc - boldsymbolK^-1(t)boldsymbolr_mathrmbc\n= boldsymbolx_mathrmbc - boldsymbolK^-1(t)leftboldsymbolK(t)boldsymbolx_mathrmbc-boldsymbolf(t)right\n= boldsymbolK^-1(t)boldsymbolf(t)\n\nis the solution to the current time step. This normally implies when using Ferrite the same procedure as for nonlinear problems, i.e.  that the boundary conditions are applied in update_to_next_step! and update_problem!, as well as the calculation of the residual  according to above and that apply_zero!(K,r,ch) is called (on both the residual and the stiffness matrix).\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.NewtonSolver","page":"Nonlinear solvers","title":"FESolvers.NewtonSolver","text":"NewtonSolver(;linsolver=BackslashSolver(), linesearch=NoLineSearch(), maxiter=10, tolerance=1.e-6)\n\nUse the standard NewtonRaphson solver to solve the nonlinear  problem r(x) = 0 with tolerance within the maximum number  of iterations maxiter. The linsolver argument determines the used linear solver whereas the linesearch can be set currently between NoLineSearch or ArmijoGoldstein. The latter globalizes the Newton strategy.\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.SteepestDescent","page":"Nonlinear solvers","title":"FESolvers.SteepestDescent","text":"SteepestDescent(;maxiter=10, tolerance=1.e-6)\n\nUse a steepest descent solver to solve the nonlinear  problem r(x) = 0, which minimizes a potential \\Pi with tolerance and the maximum number of iterations maxiter.\n\nThis method is second derivative free and is not as locally limited as a Newton-Raphson scheme. Thus, it is especially suited for stronlgy nonlinear behavior with potentially vanishing tangent stiffnesses.\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#Linesearch","page":"Nonlinear solvers","title":"Linesearch","text":"","category":"section"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"Some nonlinear solvers can use linesearch as a complement,  and the following linesearches are included. ","category":"page"},{"location":"nlsolvers/","page":"Nonlinear solvers","title":"Nonlinear solvers","text":"NoLineSearch\nArmijoGoldstein","category":"page"},{"location":"nlsolvers/#FESolvers.NoLineSearch","page":"Nonlinear solvers","title":"FESolvers.NoLineSearch","text":"Singleton that does not perform a linesearch when used in a nonlinear solver\n\n\n\n\n\n","category":"type"},{"location":"nlsolvers/#FESolvers.ArmijoGoldstein","page":"Nonlinear solvers","title":"FESolvers.ArmijoGoldstein","text":"Armijo-Goldstein{T}(;β=0.9,μ=0.01,τ0=1.0,τmin=1e-4)\n\nBacktracking line search based on the Armijo-Goldstein condition\n\nPi(boldsymbolu + tau Deltaboldsymbolu) leq Pi(boldsymbolu) - mutaudeltaPi(boldsymbolu)Delta boldsymbolu\n\nwhere $\\Pi$ is the potential, $\\tau$ the stepsize, and $\\delta\\Pi$ the residuum.\n\n#Fields\n\nβ::T = 0.9 constant factor that changes the steplength τ in each iteration\nμ::T = 0.01 second constant factor that determines how much the potential needs to decrease additionally\nτ0::T = 1.0 start stepsize \nτmin::T = 1e-4 minimal stepsize\n\n\n\n\n\n","category":"type"},{"location":"linearsolvers/#Linear-solvers","page":"Linear solvers","title":"Linear solvers","text":"","category":"section"},{"location":"linearsolvers/","page":"Linear solvers","title":"Linear solvers","text":"A linear solver should support the solve_linear! function specified below. ","category":"page"},{"location":"linearsolvers/","page":"Linear solvers","title":"Linear solvers","text":"FESolvers.solve_linear!","category":"page"},{"location":"linearsolvers/#FESolvers.solve_linear!","page":"Linear solvers","title":"FESolvers.solve_linear!","text":"solve_linear!(Δx, K, r, linearsolver)\n\nUsing the method specified by linearsolver,  solve K Δx = -r for Δx\n\n\n\n\n\n","category":"function"},{"location":"linearsolvers/#Implemented-Solvers","page":"Linear solvers","title":"Implemented Solvers","text":"","category":"section"},{"location":"linearsolvers/#BackslashSolver","page":"Linear solvers","title":"BackslashSolver","text":"","category":"section"},{"location":"linearsolvers/","page":"Linear solvers","title":"Linear solvers","text":"BackslashSolver","category":"page"},{"location":"linearsolvers/#FESolvers.BackslashSolver","page":"Linear solvers","title":"FESolvers.BackslashSolver","text":"BackslashSolver()\n\nThe standard julia linear solver using Δx .= -K\\r\n\n\n\n\n\n","category":"type"},{"location":"linearsolvers/#LinearSolve.jl","page":"Linear solvers","title":"LinearSolve.jl","text":"","category":"section"},{"location":"linearsolvers/","page":"Linear solvers","title":"Linear solvers","text":"The linear solvers in LinearSolve.jl are available  if the LinearSolve.jl package is available (implemented via Requires.jl). This also includes their default solver that is supplied setting the linear solver to nothing.  Please see LinearSolve.jl's documentation for their different solvers. ","category":"page"},{"location":"userfunctions/#User-problem","page":"User problem","title":"User problem","text":"","category":"section"},{"location":"userfunctions/","page":"User problem","title":"User problem","text":"The key to using the FESolvers.jl package is to define your  problem. This problem should support a set of functions in order for the solver to solve your problem.  While some functions are always required, some are only required by certain solvers.  Furthermore, a two-level API exist: Simple and advanced.  The simple API does not expose which solver is used, while the advanced API requires you to dispatch on the type of solver. ","category":"page"},{"location":"userfunctions/#Applicable-to-all-solvers","page":"User problem","title":"Applicable to all solvers","text":"","category":"section"},{"location":"userfunctions/","page":"User problem","title":"User problem","text":"FESolvers.getunknowns\nFESolvers.getresidual\nFESolvers.update_to_next_step!\nFESolvers.update_problem!\nFESolvers.handle_converged!\nFESolvers.postprocess!","category":"page"},{"location":"userfunctions/#FESolvers.getunknowns","page":"User problem","title":"FESolvers.getunknowns","text":"getunknowns(problem)\n\nReturn the current vector of unknown values\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.getresidual","page":"User problem","title":"FESolvers.getresidual","text":"getresidual(problem)\n\nReturn the current residual vector of the problem\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.update_to_next_step!","page":"User problem","title":"FESolvers.update_to_next_step!","text":"update_to_next_step!(problem, time)\n\nUpdate prescribed values, external loads etc. for the given time.\n\nThis function is called in the beginning of each new time step.  Note that for adaptive time stepping, it may be called with a lower  time than the previous time if the solution did not converge.\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.update_problem!","page":"User problem","title":"FESolvers.update_problem!","text":"update_problem!(problem, Δx; update_residual::Bool, update_jacobian::Bool)\n\nUpdate the unknowns, x += Δx, if !isnothing(Δx), and in any case\n\nAssemble the residual if update_residual=true\nAssemble the jacobian if update_jacobian=true\n\nNote that one can also update the residual and jacobian if any of the kwargs  are false, the kwargs just states if an update is required.  A simple function overload that doesn't account for the kwargs is\n\nFESolvers.update_problem!(problem, Δx; kwargs...)\n\nSome linear solvers may be inaccurate, and if a modified stiffness is used  to enforce constraints on x, it is good the force Δx=0 on these components inside this function. \nΔx=nothing in the first call after update_to_next_step! in which case, typically, no change of x should be made. Dirichlet boundary conditions are typically updated in update_to_next_step!.\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.handle_converged!","page":"User problem","title":"FESolvers.handle_converged!","text":"handle_converged!(problem)\n\nDo necessary update operations once it is known that the  problem has converged. E.g., update old values to the current.  Only called directly after the problem has converged,  after postprocess!\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.postprocess!","page":"User problem","title":"FESolvers.postprocess!","text":"postprocess!(problem, step, solver)\npostprocess!(problem, step)\n\nPerform any postprocessing at the current time and step nr step Called after time step converged, and before handle_converged!. One can choose which version to overload, i.e. if the solver should be  given or not. \n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#Simple-API","page":"User problem","title":"Simple API","text":"","category":"section"},{"location":"userfunctions/","page":"User problem","title":"User problem","text":"FESolvers.calculate_convergence_measure\nFESolvers.getjacobian\nFESolvers.getdescentpreconditioner","category":"page"},{"location":"userfunctions/#FESolvers.calculate_convergence_measure","page":"User problem","title":"FESolvers.calculate_convergence_measure","text":"calculate_convergence_measure(problem, Δa, iter) -> AbstractFloat\n\nCalculate a value to be compared with the tolerance of the nonlinear solver.  A standard case when using Ferrite.jl is norm(getresidual(problem)[Ferrite.free_dofs(ch)])  where ch::Ferrite.ConstraintHandler. Δa is the update of the unknowns from  the previous iteration. Note that iter=1 implies Δa=0\n\nThe advanced API alternative is check_convergence_criteria\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.getjacobian","page":"User problem","title":"FESolvers.getjacobian","text":"getjacobian(problem)\n\nReturn the jacobian drdx, or approximations thereof.\n\nMust be defined for NewtonSolver, but can also be  defined by the advanced API alternative getsystemmatrix:  getsystemmatrix(problem, ::NewtonSolver)\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.getdescentpreconditioner","page":"User problem","title":"FESolvers.getdescentpreconditioner","text":"getdescentpreconditioner(problem)\n\nReturn a preconditioner K for calculating the descent direction p, considering solving r(x)=0 as a minimization problem of f(x) where r=∇f. The descent direction is then p = K⁻¹ ∇f\n\nUsed by the SteepestDescent solver, and defaults to I if not defined.  The advanced API alternative is getsystemmatrix:  getsystemmatrix(problem, ::SteepestDescent)\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#Advanced-API","page":"User problem","title":"Advanced API","text":"","category":"section"},{"location":"userfunctions/","page":"User problem","title":"User problem","text":"FESolvers.getsystemmatrix\nFESolvers.check_convergence_criteria","category":"page"},{"location":"userfunctions/#FESolvers.getsystemmatrix","page":"User problem","title":"FESolvers.getsystemmatrix","text":"getsystemmatrix(problem,nlsolver)\n\nReturn the system matrix of the problem. For a Newton solver this method should return the Jacobian, while for a steepest descent method this can be a preconditioner as e.g., the L2 product of the gradients. By default the system matrix for the SteepestDescent method is the unity matrix and thus, renders a vanilla gradient descent solver.\n\n\n\n\n\n","category":"function"},{"location":"userfunctions/#FESolvers.check_convergence_criteria","page":"User problem","title":"FESolvers.check_convergence_criteria","text":"check_convergence_criteria(problem, nlsolver, Δa, iter) -> Bool\n\nCheck if problem has converged and update the state  of nlsolver wrt. number of iterations and a convergence measure if applicable.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FESolvers","category":"page"},{"location":"#FESolvers","page":"Home","title":"FESolvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for FESolvers.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"solve_problem!\nQuasiStaticSolver","category":"page"},{"location":"#FESolvers.solve_problem!","page":"Home","title":"FESolvers.solve_problem!","text":"solve_problem!(problem, solver)\n\nSolve a given user problem using the chosen solver\n\nFor details on the functions that should be defined for problem, see User problem\n\n\n\n\n\n","category":"function"},{"location":"#FESolvers.QuasiStaticSolver","page":"Home","title":"FESolvers.QuasiStaticSolver","text":"QuasiStaticSolver(nlsolver, timestepper)\n\nA quasi-static solver that solves problems of the type R(X(t),t)=0.  It has two parts: A nonlinear solver (see Nonlinear solvers)  and a time stepper (see Time steppers). \n\n\n\n\n\n","category":"type"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"EditURL = \"https://github.com/KnutAM/FESolvers.jl/blob/main/docs/src/literate/transient_heat.jl\"","category":"page"},{"location":"examples/transient_heat/#Linear-Time-Dependent-Problem","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"This example is taken from Ferrite.jl's transient heat flow. We modify the material parameters to get more time-dependent behavior.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Currently, only Quasi-static problems are supported by FESolvers. Therefore, we reformulate the linear system compared to remove the mass matrices. We have the same time-discretized weak form:","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"int_Omega v u_n+1 mathrmdOmega + Delta tint_Omega k nabla v cdot nabla u_n+1  mathrmdOmega = Delta tint_Omega v f  mathrmdOmega + int_Omega v  u_n  mathrmdOmega","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We then define the linear residual, r(u_n+1), as","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"r(u_n+1) = f_mathrmint(u_n+1) - f_mathrmext(u_n) \nf_mathrmint(u_n+1) = int_Omega v u_n+1 mathrmdOmega + Delta tint_Omega k nabla v cdot nabla u_n+1  mathrmdOmega  \nf_mathrmext(u_n) = Delta tint_Omega v f  mathrmdOmega + int_Omega v  u_n  mathrmdOmega ","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"giving the discrete operators","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"r_i(mathbfu_n+1) = K_ij mathbfu_n+1_j - mathbff_mathrmext(u_n)_i","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"upon introduction of the function approximation, u(mathbfx) approx N_i(mathbfx) u_i, and the test approximation, v(mathbfx) approx delta N_i(mathbfx) v_i where","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"K_ij = int_Omega delta N_i(mathbfx) N_j(mathbfx)  mathrmdOmega + Delta tint_Omega k nabla delta N_i(mathbfx) cdot nabla N_j(mathbfx)  mathrmdOmega  \nleftmathbff_mathrmext(u_n)right_i = Delta tint_Omega delta N_i(mathbfx) f  mathrmdOmega + int_Omega delta N_i(mathbfx)  u_n(mathbfx)  mathrmdOmega","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"and the residual expression can be simplified to","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"r_i =\nint_Omega delta N_i(mathbfx) leftu(mathbfx)-u_n(mathbfx)right  mathrmdOmega\n+ Delta tint_Omega k nabla delta N_i(mathbfx) cdot nabla u(mathbfx)  mathrmdOmega\n- Delta tint_Omega delta N_i(mathbfx) f  mathrmdOmega","category":"page"},{"location":"examples/transient_heat/#Commented-Program","page":"Linear Time Dependent Problem","title":"Commented Program","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Now we solve the problem by using Ferrite and FESolvers. The full program, without comments, can be found in the next section.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"First we load Ferrite, and some other packages we need.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"using Ferrite, SparseArrays, FESolvers","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Then, we define our problem structs. At the end, we will define a nice constructor for this.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"struct TransientHeat{DEF,BUF,POST}\n    def::DEF    # Problem definition\n    buf::BUF    # Buffers for storing values\n    post::POST  # Struct to save simulation data in each step\nend\n\nstruct ProblemDefinition{DH,CH,CV}\n    dh::DH\n    ch::CH\n    cv::CV\nend\n\nfunction ProblemDefinition()\n    # **Grid**\n    grid = generate_grid(Quadrilateral, (100, 100));\n\n    # **Cell values**\n    dim = 2\n    ip = Lagrange{dim, RefCube, 1}()\n    qr = QuadratureRule{dim, RefCube}(2)\n    cellvalues = CellScalarValues(qr, ip);\n\n    # **Degrees of freedom**\n    # After this, we can define the `DofHandler` and distribute the DOFs of the problem.\n    dh = DofHandler(grid)\n    push!(dh, :u, 1)\n    close!(dh);\n\n    # **Boundary conditions**\n    # In order to define the time dependent problem, we need some end time `T` and something that describes\n    # the linearly increasing Dirichlet boundary condition on $\\partial \\Omega_2$.\n    max_temp = 100\n    t_rise = 100\n    ch = ConstraintHandler(dh);\n\n    # Here, we define the boundary condition related to $\\partial \\Omega_1$.\n    ∂Ω₁ = union(getfaceset.((grid,), [\"left\", \"right\"])...)\n    dbc = Dirichlet(:u, ∂Ω₁, (x, t) -> 0)\n    add!(ch, dbc);\n    # While the next code block corresponds to the linearly increasing temperature description on $\\partial \\Omega_2$\n    # until `t=t_rise`, and then keep constant\n    ∂Ω₂ = union(getfaceset.((grid,), [\"top\", \"bottom\"])...)\n    dbc = Dirichlet(:u, ∂Ω₂, (x, t) -> max_temp * clamp(t / t_rise, 0, 1))\n    add!(ch, dbc)\n    close!(ch)\n    return ProblemDefinition(dh, ch, cellvalues)\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We then define a problem buffer, that can be created based on the ProblemDefinition","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"struct ProblemBuffer{KT,T}\n    K::KT\n    r::Vector{T}\n    u::Vector{T}\n    uold::Vector{T}\n    times::Vector{T}    # [t_old, t_current]\nend\nfunction ProblemBuffer(def::ProblemDefinition)\n    dh = def.dh\n    K = create_sparsity_pattern(dh)\n    r = zeros(ndofs(dh))\n    u = zeros(ndofs(dh))\n    uold = zeros(ndofs(dh))\n    times = zeros(2)\n    return ProblemBuffer(K, r, u, uold, times)\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We also need functions to assemble the stiffness and residual vectors","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function doassemble!(K::SparseMatrixCSC, r::Vector, cellvalues::CellScalarValues, dh::DofHandler, u, uold, Δt)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    re = zeros(n_basefuncs)\n    ue = zeros(n_basefuncs)\n    ue_old = zeros(n_basefuncs)\n    assembler = start_assemble(K, r)\n    for cell in CellIterator(dh)\n        fill!(Ke, 0)\n        fill!(re, 0)\n        ue .= u[celldofs(cell)]\n        ue_old .= uold[celldofs(cell)]\n        reinit!(cellvalues, cell)\n        element_routine!(Ke, re, cellvalues, ue, ue_old, Δt)\n        assemble!(assembler, celldofs(cell), re, Ke)\n    end\nend\n\nfunction element_routine!(Ke, re, cellvalues, ue, ue_old, Δt, k=1.0e-3, f=0.5)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        u = function_value(cellvalues, q_point, ue)\n        uold = function_value(cellvalues, q_point, ue_old)\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        for i in 1:n_basefuncs\n            δN = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            re[i] += (δN * (u - uold - Δt * f) + Δt * k * ∇δN ⋅ ∇u) * dΩ\n            for j in 1:n_basefuncs\n                N = shape_value(cellvalues, q_point, j)\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                Ke[i, j] += (δN*N + Δt * k * (∇δN ⋅ ∇N)) * dΩ\n            end\n        end\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We now define all the required methods for solving this system with using the LinearProblemSolver","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"FESolvers.getunknowns(p::TransientHeat) = p.buf.u\nFESolvers.getresidual(p::TransientHeat) = p.buf.r\nFESolvers.getjacobian(p::TransientHeat) = p.buf.K\n\nfunction FESolvers.update_to_next_step!(p::TransientHeat, time)\n    p.buf.times[2] = time       # Update current time\n    update!(p.def.ch, time)     # Update Dirichlet boundary conditions\n    apply!(FESolvers.getunknowns(p), p.def.ch)\nend\n\nfunction FESolvers.update_problem!(p::TransientHeat, Δu; update_jacobian, update_residual)\n    if !isnothing(Δu)\n        apply_zero!(Δu, p.def.ch)\n        p.buf.u .+= Δu\n    end\n    # Since the problem is linear, we can save some computations by only updating once per time step\n    # and not after updating the temperatures to check that it has converged.\n    if update_jacobian || update_residual\n        Δt = p.buf.times[2]-p.buf.times[1]\n        doassemble!(p.buf.K, p.buf.r, p.def.cv, p.def.dh, FESolvers.getunknowns(p), p.buf.uold, Δt)\n        apply_zero!(FESolvers.getjacobian(p), FESolvers.getresidual(p), p.def.ch)\n    end\n    return nothing\nend\n\nfunction FESolvers.handle_converged!(p::TransientHeat)\n    copy!(p.buf.uold, FESolvers.getunknowns(p)) # Set old temperature to current\n    p.buf.times[1] = p.buf.times[2]             # Set old time to current\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We are now ready to solve the system, but to save some data we must define some postprocessing tasks In this example, we only save things to file","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"struct PostProcessing{PVD}\n    pvd::PVD\nend\nPostProcessing() = PostProcessing(paraview_collection(\"transient-heat.pvd\"));\n\nfunction FESolvers.postprocess!(p::TransientHeat, step)\n    vtk_grid(\"transient-heat-$step\", p.def.dh) do vtk\n        vtk_point_data(vtk, p.def.dh, p.buf.u)\n        vtk_save(vtk)\n        p.post.pvd[step] = vtk\n    end\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"At the end of the simulation, we want to finish all IO operations. We can then define the function close_problem which will be called even in the case that an error is thrown during the simulation","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"function FESolvers.close_problem(p::TransientHeat)\n    vtk_save(p.post.pvd)\nend;\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"We then define a nice constructor for TransientHeat and can solve the problem,","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"TransientHeat(def) = TransientHeat(def, ProblemBuffer(def), PostProcessing());\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"And now we create the problem type, and define the QuasiStaticSolver with the LinearProblemSolver as well as fixed time steps","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"problem = TransientHeat(ProblemDefinition())\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(collect(0.0:1.0:200)));\nnothing #hide","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Finally, we can solve the problem","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"solve_problem!(problem, solver);\nnothing #hide","category":"page"},{"location":"examples/transient_heat/#transient_heat_equation-plain-program","page":"Linear Time Dependent Problem","title":"Plain program","text":"","category":"section"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"Here follows a version of the program without any comments. The file is also available here: transient_heat_equation.jl.","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"using Ferrite, SparseArrays, FESolvers\n\nstruct TransientHeat{DEF,BUF,POST}\n    def::DEF    # Problem definition\n    buf::BUF    # Buffers for storing values\n    post::POST  # Struct to save simulation data in each step\nend\n\nstruct ProblemDefinition{DH,CH,CV}\n    dh::DH\n    ch::CH\n    cv::CV\nend\n\nfunction ProblemDefinition()\n    # **Grid**\n    grid = generate_grid(Quadrilateral, (100, 100));\n\n    # **Cell values**\n    dim = 2\n    ip = Lagrange{dim, RefCube, 1}()\n    qr = QuadratureRule{dim, RefCube}(2)\n    cellvalues = CellScalarValues(qr, ip);\n\n    # **Degrees of freedom**\n    # After this, we can define the `DofHandler` and distribute the DOFs of the problem.\n    dh = DofHandler(grid)\n    push!(dh, :u, 1)\n    close!(dh);\n\n    # **Boundary conditions**\n    # In order to define the time dependent problem, we need some end time `T` and something that describes\n    # the linearly increasing Dirichlet boundary condition on $\\partial \\Omega_2$.\n    max_temp = 100\n    t_rise = 100\n    ch = ConstraintHandler(dh);\n\n    # Here, we define the boundary condition related to $\\partial \\Omega_1$.\n    ∂Ω₁ = union(getfaceset.((grid,), [\"left\", \"right\"])...)\n    dbc = Dirichlet(:u, ∂Ω₁, (x, t) -> 0)\n    add!(ch, dbc);\n    # While the next code block corresponds to the linearly increasing temperature description on $\\partial \\Omega_2$\n    # until `t=t_rise`, and then keep constant\n    ∂Ω₂ = union(getfaceset.((grid,), [\"top\", \"bottom\"])...)\n    dbc = Dirichlet(:u, ∂Ω₂, (x, t) -> max_temp * clamp(t / t_rise, 0, 1))\n    add!(ch, dbc)\n    close!(ch)\n    return ProblemDefinition(dh, ch, cellvalues)\nend;\n\nstruct ProblemBuffer{KT,T}\n    K::KT\n    r::Vector{T}\n    u::Vector{T}\n    uold::Vector{T}\n    times::Vector{T}    # [t_old, t_current]\nend\nfunction ProblemBuffer(def::ProblemDefinition)\n    dh = def.dh\n    K = create_sparsity_pattern(dh)\n    r = zeros(ndofs(dh))\n    u = zeros(ndofs(dh))\n    uold = zeros(ndofs(dh))\n    times = zeros(2)\n    return ProblemBuffer(K, r, u, uold, times)\nend;\n\nfunction doassemble!(K::SparseMatrixCSC, r::Vector, cellvalues::CellScalarValues, dh::DofHandler, u, uold, Δt)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    Ke = zeros(n_basefuncs, n_basefuncs)\n    re = zeros(n_basefuncs)\n    ue = zeros(n_basefuncs)\n    ue_old = zeros(n_basefuncs)\n    assembler = start_assemble(K, r)\n    for cell in CellIterator(dh)\n        fill!(Ke, 0)\n        fill!(re, 0)\n        ue .= u[celldofs(cell)]\n        ue_old .= uold[celldofs(cell)]\n        reinit!(cellvalues, cell)\n        element_routine!(Ke, re, cellvalues, ue, ue_old, Δt)\n        assemble!(assembler, celldofs(cell), re, Ke)\n    end\nend\n\nfunction element_routine!(Ke, re, cellvalues, ue, ue_old, Δt, k=1.0e-3, f=0.5)\n    n_basefuncs = getnbasefunctions(cellvalues)\n    for q_point in 1:getnquadpoints(cellvalues)\n        dΩ = getdetJdV(cellvalues, q_point)\n        u = function_value(cellvalues, q_point, ue)\n        uold = function_value(cellvalues, q_point, ue_old)\n        ∇u = function_gradient(cellvalues, q_point, ue)\n        for i in 1:n_basefuncs\n            δN = shape_value(cellvalues, q_point, i)\n            ∇δN = shape_gradient(cellvalues, q_point, i)\n            re[i] += (δN * (u - uold - Δt * f) + Δt * k * ∇δN ⋅ ∇u) * dΩ\n            for j in 1:n_basefuncs\n                N = shape_value(cellvalues, q_point, j)\n                ∇N = shape_gradient(cellvalues, q_point, j)\n                Ke[i, j] += (δN*N + Δt * k * (∇δN ⋅ ∇N)) * dΩ\n            end\n        end\n    end\nend;\n\nFESolvers.getunknowns(p::TransientHeat) = p.buf.u\nFESolvers.getresidual(p::TransientHeat) = p.buf.r\nFESolvers.getjacobian(p::TransientHeat) = p.buf.K\n\nfunction FESolvers.update_to_next_step!(p::TransientHeat, time)\n    p.buf.times[2] = time       # Update current time\n    update!(p.def.ch, time)     # Update Dirichlet boundary conditions\n    apply!(FESolvers.getunknowns(p), p.def.ch)\nend\n\nfunction FESolvers.update_problem!(p::TransientHeat, Δu; update_jacobian, update_residual)\n    if !isnothing(Δu)\n        apply_zero!(Δu, p.def.ch)\n        p.buf.u .+= Δu\n    end\n    # Since the problem is linear, we can save some computations by only updating once per time step\n    # and not after updating the temperatures to check that it has converged.\n    if update_jacobian || update_residual\n        Δt = p.buf.times[2]-p.buf.times[1]\n        doassemble!(p.buf.K, p.buf.r, p.def.cv, p.def.dh, FESolvers.getunknowns(p), p.buf.uold, Δt)\n        apply_zero!(FESolvers.getjacobian(p), FESolvers.getresidual(p), p.def.ch)\n    end\n    return nothing\nend\n\nfunction FESolvers.handle_converged!(p::TransientHeat)\n    copy!(p.buf.uold, FESolvers.getunknowns(p)) # Set old temperature to current\n    p.buf.times[1] = p.buf.times[2]             # Set old time to current\nend;\n\nstruct PostProcessing{PVD}\n    pvd::PVD\nend\nPostProcessing() = PostProcessing(paraview_collection(\"transient-heat.pvd\"));\n\nfunction FESolvers.postprocess!(p::TransientHeat, step)\n    vtk_grid(\"transient-heat-$step\", p.def.dh) do vtk\n        vtk_point_data(vtk, p.def.dh, p.buf.u)\n        vtk_save(vtk)\n        p.post.pvd[step] = vtk\n    end\nend;\n\nfunction FESolvers.close_problem(p::TransientHeat)\n    vtk_save(p.post.pvd)\nend;\n\nTransientHeat(def) = TransientHeat(def, ProblemBuffer(def), PostProcessing());\n\nproblem = TransientHeat(ProblemDefinition())\nsolver = QuasiStaticSolver(;nlsolver=LinearProblemSolver(), timestepper=FixedTimeStepper(collect(0.0:1.0:200)));\n\nsolve_problem!(problem, solver);\n\n# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"","category":"page"},{"location":"examples/transient_heat/","page":"Linear Time Dependent Problem","title":"Linear Time Dependent Problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"timesteppers/#Time-steppers","page":"Time steppers","title":"Time steppers","text":"","category":"section"},{"location":"timesteppers/","page":"Time steppers","title":"Time steppers","text":"A time stepper should support the following functions","category":"page"},{"location":"timesteppers/","page":"Time steppers","title":"Time steppers","text":"FESolvers.initial_time\nFESolvers.islaststep\nFESolvers.update_time","category":"page"},{"location":"timesteppers/#FESolvers.initial_time","page":"Time steppers","title":"FESolvers.initial_time","text":"initial_time(timestepper)\n\nReturn the starting time for the given timestepper\n\n\n\n\n\n","category":"function"},{"location":"timesteppers/#FESolvers.islaststep","page":"Time steppers","title":"FESolvers.islaststep","text":"islaststep(timestepper, time, step)->Bool\n\nReturn true if the current step/time is the last step, return false otherwise \n\n\n\n\n\n","category":"function"},{"location":"timesteppers/#FESolvers.update_time","page":"Time steppers","title":"FESolvers.update_time","text":"update_time(solver, time, step, converged::Bool)\nupdate_time(timestepper, nlsolver, time, step, converged::Bool)\n\nReturn the next time and step number, depending on if the previous time step converged  or not. If not converged, return the same step but a new_time<time to reduce the  time step. If it is not possible to retry with shorter timestep, throw  ConvergenceError. If converged, update time step as planned.  Note: The full solver is given as input to allow specialization on e.g. if a  Newton iteration has required many iterations, shorten the next time step as a  precausionary step.\n\nNote that a call to the first definition is forwarded to the second function definition  by decomposing the solver, unless another specialization is defined.\n\n\n\n\n\n","category":"function"},{"location":"timesteppers/#Implemented-steppers","page":"Time steppers","title":"Implemented steppers","text":"","category":"section"},{"location":"timesteppers/","page":"Time steppers","title":"Time steppers","text":"FixedTimeStepper\nAdaptiveTimeStepper","category":"page"},{"location":"timesteppers/#FESolvers.FixedTimeStepper","page":"Time steppers","title":"FESolvers.FixedTimeStepper","text":"FixedTimeStepper(num_steps::int, Δt, t_start=0)\nFixedTimeStepper(t::Vector)\n\nA time stepper which gives fixed time steps. If the convenience interface is used, constant increments are used. Note that  length(t)=num_steps+1 since the first value is just the initial  value and is not an actual step.  \n\n\n\n\n\n","category":"type"},{"location":"timesteppers/#FESolvers.AdaptiveTimeStepper","page":"Time steppers","title":"FESolvers.AdaptiveTimeStepper","text":"AdaptiveTimeStepper(\n    Δt_init::T, t_end::T; \n    t_start=zero(T), Δt_min=Δt_init, Δt_max=typemax(T), \n    change_factor=T(0.5), optiter_ratio=T(0.5), k=one(T)) where T\n\nAn adaptive time stepper with an initial step Δt_init and total   time t_end. Two ways of adaption:\n\nIf the previous attempt did not converge, the time \n\nstep is reduced as Δt*=change_factor and the step is retried. \n\nIf convergence, the next time step depends on how many iterations was \n\nrequired to converge; numiter. The time step is changed as  Δt*=change_factor^(k*m), where m=(numiter-optiter)/(maxiter-optiter). In this expression, maxiter and optiter are the maximum and optimum  number of iterations for the nonlinear solver.  optiter=floor(maxiter*optiter_ratio) and maxiter is obtained from  the nonlinear solver (via getmaxiter(s))\n\nIf numiter=maxiter, then m=1 and the time step update is the same as for a non-converged solution if k=1. Note that k>0, change_factor∈[0,1], and optiter_ratio∈[0,1] are expected, otherwise warnings are thrown. \n\n\n\n\n\n","category":"type"}]
}
