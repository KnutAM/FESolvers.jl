<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Plasticity · FerriteSolvers.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://KnutAM.github.io/FerriteSolvers.jl/examples/plasticity/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">FerriteSolvers.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../userfunctions/">User problem</a></li><li><a class="tocitem" href="../../nlsolvers/">Nonlinear solvers</a></li><li><a class="tocitem" href="../../timesteppers/">Time steppers</a></li><li><a class="tocitem" href="../../linearsolvers/">Linear solvers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Plasticity</a><ul class="internal"><li><a class="tocitem" href="#Problem-definition"><span>Problem definition</span></a></li><li><a class="tocitem" href="#Neumann-boundary-conditions"><span>Neumann boundary conditions</span></a></li><li><a class="tocitem" href="#Specialized-functions-for-our-problem"><span>Specialized functions for our problem</span></a></li><li><a class="tocitem" href="#Solving-the-problem"><span>Solving the problem</span></a></li><li><a class="tocitem" href="#Plain-program"><span>Plain program</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Plasticity</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Plasticity</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/KnutAM/FerriteSolvers.jl/blob/main/docs/src/literate/plasticity.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Plasticity"><a class="docs-heading-anchor" href="#Plasticity">Plasticity</a><a id="Plasticity-1"></a><a class="docs-heading-anchor-permalink" href="#Plasticity" title="Permalink"></a></h1><p>This example is taken from <a href="https://ferrite-fem.github.io/Ferrite.jl/stable/examples/plasticity/">Ferrite.jl&#39;s plasticity example</a> and shows how <code>FerriteSolvers</code> can be used to solve this nonlinear problem with time dependent loading.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This example is preliminary, and does not represent good coding practice. This will be improved in the future as the <code>FerriteSolvers</code> package matures</p></div></div><p>First we need to load all required packages</p><pre><code class="language-julia hljs">using FerriteSolvers, Ferrite, Tensors, SparseArrays, LinearAlgebra, Plots</code></pre><p>We first include some basic definitions taken and modified from the original <a href="https://ferrite-fem.github.io/Ferrite.jl/stable/examples/plasticity/">example</a>. These definitions are available here: <a href="../plasticity_definitions.jl">plasticity_definitions.jl</a></p><pre><code class="language-julia hljs">include(&quot;plasticity_definitions.jl&quot;);</code></pre><h2 id="Problem-definition"><a class="docs-heading-anchor" href="#Problem-definition">Problem definition</a><a id="Problem-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-definition" title="Permalink"></a></h2><p>We divide the problem struct into three parts: definitions (<code>def</code>), a buffer (<code>buf</code>), and postprocessing (<code>post</code>) to structure the information and make it easier to save the simulation settings (enough to save <code>def</code> as the others will be created based on this one)</p><pre><code class="language-julia hljs">struct PlasticityProblem{PD,PB,PP}
    def::PD
    buf::PB
    post::PP
end</code></pre><p><code>PlasticityModel</code> is our <code>def</code> and contain all problem settings (mesh, material, loads, interpolations, etc.)</p><pre><code class="language-julia hljs">struct PlasticityModel
    grid
    interpolation
    dh
    material
    traction_rate
    dbcs
end

function PlasticityModel()
    E = 200.0e9
    H = E/20
    ν = 0.3
    σ₀ = 200e6
    material = J2Plasticity(E, ν, σ₀, H)

    L = 10.0
    w = 1.0
    h = 1.0

    traction_rate = 1.e7    # N/s

    n = 2
    nels = (10n, n, 2n)
    P1 = Vec((0.0, 0.0, 0.0))
    P2 = Vec((L, w, h))
    grid = generate_grid(Tetrahedron, nels, P1, P2)
    interpolation = Lagrange{3, RefTetrahedron, 1}()
    dh = create_dofhandler(grid, interpolation)
    dbcs = create_bc(dh, grid)
    return PlasticityModel(grid,interpolation,dh,material,traction_rate,dbcs)
end;</code></pre><p><code>PlasticityFEBuffer</code> is our <code>buf</code> and contain all problem arrays and other allocated values</p><pre><code class="language-julia hljs">struct PlasticityFEBuffer
    cellvalues
    facevalues
    K
    r
    u
    states
    states_old
    time::Vector # length(time)=1, could use ScalarBuffer instead
end

function build_febuffer(model::PlasticityModel)
    dh = model.dh
    n_dofs = ndofs(dh)
    cellvalues, facevalues = create_values(model.interpolation)
    u  = zeros(n_dofs)
    r = zeros(n_dofs)
    K = create_sparsity_pattern(dh)
    nqp = getnquadpoints(cellvalues)
    states = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.grid)]
    states_old = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.grid)]
    return PlasticityFEBuffer(cellvalues,facevalues,K,r,u,states,states_old,[0.0])
end;</code></pre><p>Finally, we define our <code>post</code> that contains variables that we will save during the simulation</p><pre><code class="language-julia hljs">struct PlasticityPost{T}
    umax::Vector{T}
    tmag::Vector{T}
end
PlasticityPost() = PlasticityPost(Float64[],Float64[]);</code></pre><p>To facilitate reuse, we define a function that gives our full problem struct based on the problem definition</p><pre><code class="language-julia hljs">build_problem(def::PlasticityModel) = PlasticityProblem(def, build_febuffer(def), PlasticityPost());</code></pre><h2 id="Neumann-boundary-conditions"><a class="docs-heading-anchor" href="#Neumann-boundary-conditions">Neumann boundary conditions</a><a id="Neumann-boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Neumann-boundary-conditions" title="Permalink"></a></h2><p>We then define a separate function for the Neumann boundary conditions (note that this difference to the original example is not required, but only to separate the element assembly and external boundary conditions)</p><pre><code class="language-julia hljs">function apply_neumann!(model::PlasticityModel,buffer::PlasticityFEBuffer)
    t = buffer.time[1]
    nu = getnbasefunctions(buffer.cellvalues)
    re = zeros(nu)
    facevalues = buffer.facevalues
    grid = model.grid
    traction = Vec((0.0, 0.0, model.traction_rate*t))

    for (i, cell) in enumerate(CellIterator(model.dh))
        fill!(re, 0)
        eldofs = celldofs(cell)
        for face in 1:nfaces(cell)
            if onboundary(cell, face) &amp;&amp; (cellid(cell), face) ∈ getfaceset(grid, &quot;right&quot;)
                reinit!(facevalues, cell, face)
                for q_point in 1:getnquadpoints(facevalues)
                    dΓ = getdetJdV(facevalues, q_point)
                    for i in 1:nu
                        δu = shape_value(facevalues, q_point, i)
                        re[i] -= (δu ⋅ traction) * dΓ
                    end
                end
            end
        end
        buffer.r[eldofs] .+= re
    end
end;</code></pre><h2 id="Specialized-functions-for-our-problem"><a class="docs-heading-anchor" href="#Specialized-functions-for-our-problem">Specialized functions for our problem</a><a id="Specialized-functions-for-our-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Specialized-functions-for-our-problem" title="Permalink"></a></h2><p>We first define our &quot;get&quot;-functions to get the key arrays for our problem. Note that these functions don&#39;t calculate or update anything, that updating is taken care of by <code>update-update_to_next_step!</code> and <code>update_problem!</code> below.</p><pre><code class="language-julia hljs">FerriteSolvers.getunknowns(p::PlasticityProblem) = p.buf.u;
FerriteSolvers.getresidual(p::PlasticityProblem) = p.buf.r;
FerriteSolvers.getjacobian(p::PlasticityProblem) = p.buf.K;</code></pre><p>We then define the function to update the problem to a different time. This is typically used to set time dependent boundary conditions. Here, it is also possible to make an improved guess for the solution to this time step if desired.</p><pre><code class="language-julia hljs">function FerriteSolvers.update_to_next_step!(p::PlasticityProblem, time)
    p.buf.time .= time
end;</code></pre><p>Next, we define the updating of the problem given a new guess to the solution. Note that we use <code>Δu=nothing</code> for the case it is not given, to signal no change. This version is called directly after update<em>to</em>next_step! before entering the nonlinear iterations.</p><pre><code class="language-julia hljs">function FerriteSolvers.update_problem!(p::PlasticityProblem, Δu=nothing)
    buf = p.buf
    def = p.def
    if !isnothing(Δu)
        apply_zero!(Δu, p.def.dbcs)
        buf.u .+= Δu
    end
    doassemble!(buf.cellvalues, buf.facevalues, buf.K, buf.r,
                def.grid, def.dh, def.material, buf.u, buf.states, buf.states_old)
    apply_neumann!(def,buf)
    apply_zero!(buf.K, buf.r, def.dbcs)
end;</code></pre><p>In this example, we use the standard convergence criterion that the norm of the free degrees of freedom is less than the iteration tolerance.</p><pre><code class="language-julia hljs">FerriteSolvers.calculate_convergence_criterion(p::PlasticityProblem) = norm(FerriteSolvers.getresidual(p)[free_dofs(p.def.dbcs)]);</code></pre><p>After convergence, we need to update the state variables.</p><pre><code class="language-julia hljs">function FerriteSolvers.handle_converged!(p::PlasticityProblem)
    p.buf.states_old .= p.buf.states
end;</code></pre><p>As postprocessing, which is called after <code>handle_converged!</code>, we save the maximum displacement as well as the traction magnitude.</p><pre><code class="language-julia hljs">function FerriteSolvers.postprocess!(p::PlasticityProblem, step)
    push!(p.post.umax, maximum(abs, FerriteSolvers.getunknowns(p)))
    push!(p.post.tmag, p.def.traction_rate*p.buf.time[1])
end;</code></pre><h2 id="Solving-the-problem"><a class="docs-heading-anchor" href="#Solving-the-problem">Solving the problem</a><a id="Solving-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-the-problem" title="Permalink"></a></h2><p>First, we define a helper function to plot the results after the solution</p><pre><code class="language-julia hljs">function plot_results(problem::PlasticityProblem; plt=plot(), label=nothing, markershape=:auto, markersize=4)
    umax = vcat(0.0, problem.post.umax)
    tmag = vcat(0.0, problem.post.tmag)
    plot!(plt, umax, tmag, linewidth=0.5, title=&quot;Traction-displacement&quot;, label=label,
        markeralpha=0.75, markershape=markershape, markersize=markersize)
    ylabel!(plt, &quot;Traction [Pa]&quot;)
    xlabel!(plt, &quot;Maximum deflection [m]&quot;)
    return plt
end;</code></pre><p>Finally, we can solve the problem with different time stepping strategies and plot the results</p><pre><code class="language-julia hljs">function example_solution()
    def = PlasticityModel()

    # Fixed uniform time steps
    problem = build_problem(def)
    solver = FerriteSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(25,0.04))
    solve_ferrite_problem!(solver, problem)
    plt = plot_results(problem, label=&quot;uniform&quot;, markershape=:x, markersize=5)

    # Same time steps as Ferrite example
    problem = build_problem(def)
    solver = FerriteSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))
    solve_ferrite_problem!(solver, problem)
    plot_results(problem, plt=plt, label=&quot;fixed&quot;, markershape=:circle)

    # Adaptive time stepping
    problem = build_problem(def)
    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)
    solver = FerriteSolver(NewtonSolver(;tolerance=1.0, maxiter=4), ts)
    solve_ferrite_problem!(solver, problem)
    println(problem.buf.time)
    plot_results(problem, plt=plt, label=&quot;adaptive&quot;, markershape=:circle)
    plot!(;legend=:bottomright)
end;</code></pre><p>Which gives the following result <img src="../plasticity.svg" alt/></p><h2 id="Plain-program"><a class="docs-heading-anchor" href="#Plain-program">Plain program</a><a id="Plain-program-1"></a><a class="docs-heading-anchor-permalink" href="#Plain-program" title="Permalink"></a></h2><p>Here follows a version of the program without any comments. The file is also available here: <a href="../plasticity.jl"><code>plasticity.jl</code></a>.</p><pre><code class="language-julia hljs">using FerriteSolvers, Ferrite, Tensors, SparseArrays, LinearAlgebra, Plots

include(&quot;plasticity_definitions.jl&quot;);

struct PlasticityProblem{PD,PB,PP}
    def::PD
    buf::PB
    post::PP
end

struct PlasticityModel
    grid
    interpolation
    dh
    material
    traction_rate
    dbcs
end

function PlasticityModel()
    E = 200.0e9
    H = E/20
    ν = 0.3
    σ₀ = 200e6
    material = J2Plasticity(E, ν, σ₀, H)

    L = 10.0
    w = 1.0
    h = 1.0

    traction_rate = 1.e7    # N/s

    n = 2
    nels = (10n, n, 2n)
    P1 = Vec((0.0, 0.0, 0.0))
    P2 = Vec((L, w, h))
    grid = generate_grid(Tetrahedron, nels, P1, P2)
    interpolation = Lagrange{3, RefTetrahedron, 1}()
    dh = create_dofhandler(grid, interpolation)
    dbcs = create_bc(dh, grid)
    return PlasticityModel(grid,interpolation,dh,material,traction_rate,dbcs)
end;

struct PlasticityFEBuffer
    cellvalues
    facevalues
    K
    r
    u
    states
    states_old
    time::Vector # length(time)=1, could use ScalarBuffer instead
end

function build_febuffer(model::PlasticityModel)
    dh = model.dh
    n_dofs = ndofs(dh)
    cellvalues, facevalues = create_values(model.interpolation)
    u  = zeros(n_dofs)
    r = zeros(n_dofs)
    K = create_sparsity_pattern(dh)
    nqp = getnquadpoints(cellvalues)
    states = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.grid)]
    states_old = [J2PlasticityMaterialState() for _ in 1:nqp, _ in 1:getncells(model.grid)]
    return PlasticityFEBuffer(cellvalues,facevalues,K,r,u,states,states_old,[0.0])
end;

struct PlasticityPost{T}
    umax::Vector{T}
    tmag::Vector{T}
end
PlasticityPost() = PlasticityPost(Float64[],Float64[]);

build_problem(def::PlasticityModel) = PlasticityProblem(def, build_febuffer(def), PlasticityPost());

function apply_neumann!(model::PlasticityModel,buffer::PlasticityFEBuffer)
    t = buffer.time[1]
    nu = getnbasefunctions(buffer.cellvalues)
    re = zeros(nu)
    facevalues = buffer.facevalues
    grid = model.grid
    traction = Vec((0.0, 0.0, model.traction_rate*t))

    for (i, cell) in enumerate(CellIterator(model.dh))
        fill!(re, 0)
        eldofs = celldofs(cell)
        for face in 1:nfaces(cell)
            if onboundary(cell, face) &amp;&amp; (cellid(cell), face) ∈ getfaceset(grid, &quot;right&quot;)
                reinit!(facevalues, cell, face)
                for q_point in 1:getnquadpoints(facevalues)
                    dΓ = getdetJdV(facevalues, q_point)
                    for i in 1:nu
                        δu = shape_value(facevalues, q_point, i)
                        re[i] -= (δu ⋅ traction) * dΓ
                    end
                end
            end
        end
        buffer.r[eldofs] .+= re
    end
end;

FerriteSolvers.getunknowns(p::PlasticityProblem) = p.buf.u;
FerriteSolvers.getresidual(p::PlasticityProblem) = p.buf.r;
FerriteSolvers.getjacobian(p::PlasticityProblem) = p.buf.K;

function FerriteSolvers.update_to_next_step!(p::PlasticityProblem, time)
    p.buf.time .= time
end;

function FerriteSolvers.update_problem!(p::PlasticityProblem, Δu=nothing)
    buf = p.buf
    def = p.def
    if !isnothing(Δu)
        apply_zero!(Δu, p.def.dbcs)
        buf.u .+= Δu
    end
    doassemble!(buf.cellvalues, buf.facevalues, buf.K, buf.r,
                def.grid, def.dh, def.material, buf.u, buf.states, buf.states_old)
    apply_neumann!(def,buf)
    apply_zero!(buf.K, buf.r, def.dbcs)
end;

FerriteSolvers.calculate_convergence_criterion(p::PlasticityProblem) = norm(FerriteSolvers.getresidual(p)[free_dofs(p.def.dbcs)]);

function FerriteSolvers.handle_converged!(p::PlasticityProblem)
    p.buf.states_old .= p.buf.states
end;

function FerriteSolvers.postprocess!(p::PlasticityProblem, step)
    push!(p.post.umax, maximum(abs, FerriteSolvers.getunknowns(p)))
    push!(p.post.tmag, p.def.traction_rate*p.buf.time[1])
end;

function plot_results(problem::PlasticityProblem; plt=plot(), label=nothing, markershape=:auto, markersize=4)
    umax = vcat(0.0, problem.post.umax)
    tmag = vcat(0.0, problem.post.tmag)
    plot!(plt, umax, tmag, linewidth=0.5, title=&quot;Traction-displacement&quot;, label=label,
        markeralpha=0.75, markershape=markershape, markersize=markersize)
    ylabel!(plt, &quot;Traction [Pa]&quot;)
    xlabel!(plt, &quot;Maximum deflection [m]&quot;)
    return plt
end;

function example_solution()
    def = PlasticityModel()

    # Fixed uniform time steps
    problem = build_problem(def)
    solver = FerriteSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(25,0.04))
    solve_ferrite_problem!(solver, problem)
    plt = plot_results(problem, label=&quot;uniform&quot;, markershape=:x, markersize=5)

    # Same time steps as Ferrite example
    problem = build_problem(def)
    solver = FerriteSolver(NewtonSolver(;tolerance=1.0), FixedTimeStepper(append!([0.], collect(0.5:0.05:1.0))))
    solve_ferrite_problem!(solver, problem)
    plot_results(problem, plt=plt, label=&quot;fixed&quot;, markershape=:circle)

    # Adaptive time stepping
    problem = build_problem(def)
    ts = AdaptiveTimeStepper(0.05, 1.0; Δt_min=0.01, Δt_max=0.2)
    solver = FerriteSolver(NewtonSolver(;tolerance=1.0, maxiter=4), ts)
    solve_ferrite_problem!(solver, problem)
    println(problem.buf.time)
    plot_results(problem, plt=plt, label=&quot;adaptive&quot;, markershape=:circle)
    plot!(;legend=:bottomright)
end;

# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../linearsolvers/">« Linear solvers</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.21 on <span class="colophon-date" title="Wednesday 31 August 2022 06:22">Wednesday 31 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
